<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>BJTåŸºæœ¬æ”¾å¤§ç”µè·¯æ¨¡æ‹Ÿå·¥å…·</title>
  <script src="https://cdn.plot.ly/plotly-2.30.0.min.js"></script>
  <style>
    :root{
      --bg:#0b1020;
      --panel:#121a33;
      --panel2:#0f1730;
      --text:#e9eeff;
      --muted:#aab3d6;
      --accent:#5ad7ff;
      --good:#2ee59d;
      --warn:#ffcc66;
      --bad:#ff4d6d;
      --grid:#22305c;
      --stroke:#2b3a70;
      --shadow: rgba(0,0,0,.35);
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans", Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
      background: radial-gradient(1200px 800px at 10% 10%, #18245a 0%, var(--bg) 45%, #070a14 100%);
      color: var(--text);
      position: relative;
      overflow-x: hidden;
    }
    /* èƒŒæ™¯è½»é‡åŠ¨æ€ï¼šä¸å½±å“è®¡ç®—ï¼Œåªæä¾›æ°›å›´ */
    body::before{
      content:"";
      position: fixed;
      inset: -20% -20% -20% -20%;
      background:
        radial-gradient(700px 420px at 15% 25%, rgba(90,215,255,.18), rgba(0,0,0,0) 60%),
        radial-gradient(760px 520px at 85% 35%, rgba(46,229,157,.12), rgba(0,0,0,0) 60%),
        radial-gradient(640px 420px at 55% 85%, rgba(255,204,102,.10), rgba(0,0,0,0) 55%);
      filter: blur(18px);
      opacity: .55;
      pointer-events: none;
      z-index: -1;
      animation: floatBg 18s ease-in-out infinite;
    }
    @keyframes floatBg{
      0%{ transform: translate3d(0px,0px,0px) scale(1); }
      50%{ transform: translate3d(18px,-12px,0px) scale(1.03); }
      100%{ transform: translate3d(0px,0px,0px) scale(1); }
    }
    a{color:var(--accent)}
    .topbar{
      position: sticky;
      top:0;
      z-index: 10;
      background: linear-gradient(180deg, rgba(18,26,51,.92), rgba(18,26,51,.82));
      backdrop-filter: blur(10px);
      border-bottom: 1px solid rgba(255,255,255,.08);
      box-shadow: 0 10px 25px rgba(0,0,0,.25);
      padding: 10px 12px;
    }
    .row{
      display:flex;
      flex-wrap: wrap;
      align-items:center;
      gap:10px;
    }
    .row .spacer{flex:1}
    .chip{
      display:flex;
      align-items:center;
      gap:8px;
      background: rgba(0,0,0,.18);
      border: 1px solid rgba(255,255,255,.12);
      border-radius: 10px;
      padding: 8px 10px;
    }
    label{
      font-size:12px;
      color: var(--muted);
      margin-right: 6px;
      white-space: nowrap;
    }
    select, button, input[type="number"]{
      background: rgba(10,14,30,.75);
      border:1px solid rgba(255,255,255,.14);
      color: var(--text);
      border-radius: 10px;
      padding: 8px 10px;
      outline:none;
    }
    select:focus, button:focus, input[type="number"]:focus{
      border-color: rgba(90,215,255,.55);
      box-shadow: 0 0 0 3px rgba(90,215,255,.18);
    }
    button{
      cursor:pointer;
      font-weight:650;
      transition: transform .12s ease, filter .12s ease, background .12s ease, border-color .12s ease, box-shadow .12s ease;
    }
    button:hover{filter: brightness(1.07); transform: translateY(-1px)}
    button:active{transform: translateY(0px) scale(.99)}
    .toggle{
      min-width: 74px;
    }
    .toggle.on{
      border-color: rgba(46,229,157,.7);
      box-shadow: 0 0 0 3px rgba(46,229,157,.12);
    }
    .toggle.off{
      border-color: rgba(255,77,109,.55);
      box-shadow: 0 0 0 3px rgba(255,77,109,.10);
    }
    .btn-ghost{
      background: rgba(255,255,255,.06);
    }
    #moreBtn.active{
      border-color: rgba(90,215,255,.45);
      box-shadow: 0 0 0 3px rgba(90,215,255,.14);
    }
    .btn-good{
      background: rgba(46,229,157,.12);
      border-color: rgba(46,229,157,.35);
    }
    .btn-warn{
      background: rgba(255,204,102,.10);
      border-color: rgba(255,204,102,.35);
    }
    .btn-bad{
      background: rgba(255,77,109,.10);
      border-color: rgba(255,77,109,.35);
    }

    .banner{
      margin-top: 10px;
      padding: 8px 10px;
      border-radius: 12px;
      border:1px solid rgba(255,255,255,.12);
      display:none;
      font-size: 13px;
      line-height: 1.35;
    }
    .banner.bad{
      display:block;
      background: rgba(255,77,109,.10);
      border-color: rgba(255,77,109,.35);
      color: #ffd0d9;
    }
    .banner.warn{
      display:block;
      background: rgba(255,204,102,.10);
      border-color: rgba(255,204,102,.35);
      color: #ffe9b8;
    }
    .kpis{
      margin-top: 10px;
      display:grid;
      grid-template-columns: repeat(7, minmax(120px, 1fr));
      gap: 10px;
    }
    @media (max-width: 1400px){
      .kpis{grid-template-columns: repeat(4, minmax(140px,1fr));}
    }
    @media (max-width: 900px){
      .kpis{grid-template-columns: repeat(2, minmax(140px,1fr));}
    }
    .kpi{
      background: rgba(0,0,0,.18);
      border: 1px solid rgba(255,255,255,.10);
      border-radius: 14px;
      padding: 10px 10px;
      box-shadow: 0 10px 25px rgba(0,0,0,.18);
      min-height: 58px;
    }
    .kpi .t{font-size: 11px; color: var(--muted); margin-bottom: 4px;}
    .kpi .v{font-size: 15px; font-weight: 780;}
    .kpi .s{font-size: 11px; color: var(--muted); margin-top: 2px;}

    .layout{
      display:flex;
      gap: 12px;
      padding: 12px;
    }
    @media (max-width: 1100px){
      .layout{flex-direction: column;}
    }
    .left{
      /* å·¦ä¾§ï¼šç”µè·¯ç¤ºæ„å›¾ + å‚æ•°ï¼ˆæ›´çª„ï¼‰ */
      flex: 0.85;
      display:flex;
      flex-direction: column;
      gap: 12px;
      min-width: 420px;
    }
    @media (max-width: 1100px){
      .left{min-width: 0;}
    }
    .right{
      /* å³ä¾§ï¼šå›¾è¡¨åŒºï¼ˆæ›´å®½ï¼‰ */
      flex: 1.15;
      display:flex;
      flex-direction: column;
      gap:12px;
      min-width: 680px;
    }
    @media (max-width: 1100px){
      .right{min-width: 0;}
    }
    .card{
      background: linear-gradient(180deg, rgba(18,26,51,.80), rgba(15,23,48,.78));
      border: 1px solid rgba(255,255,255,.10);
      border-radius: 16px;
      box-shadow: 0 16px 40px rgba(0,0,0,.22);
      padding: 12px;
      transition: transform .18s ease, box-shadow .18s ease, border-color .18s ease;
    }
    .card:hover{
      transform: translateY(-1px);
      border-color: rgba(90,215,255,.18);
      box-shadow: 0 18px 55px rgba(0,0,0,.28);
    }
    .card h3{
      margin: 0 0 8px;
      font-size: 14px;
      color: var(--text);
      letter-spacing: .2px;
    }
    .subtle{
      color: var(--muted);
      font-size: 12px;
      line-height: 1.35;
    }
    .svgWrap{
      padding: 8px;
      overflow:hidden;
      height: 300px;
    }
    .paramGrid{
      display:grid;
      grid-template-columns: repeat(2, minmax(260px, 1fr));
      gap: 10px;
    }
    @media (max-width: 900px){
      .paramGrid{grid-template-columns: 1fr;}
    }

    /* é«˜çº§å‚æ•°æ”¶çº³ï¼ˆæŠ˜å ï¼‰ */
    details.advDetails{
      grid-column: 1 / -1;
      background: rgba(0,0,0,.10);
      border: 1px dashed rgba(255,255,255,.16);
      border-radius: 14px;
      padding: 8px;
    }
    details.advDetails > summary{
      cursor:pointer;
      font-weight: 850;
      color: #e9eeff;
      list-style: none;
    }
    details.advDetails > summary::-webkit-details-marker{display:none;}
    details.advDetails > summary::before{
      content: "â–¸";
      display: inline-block;
      margin-right: 8px;
      color: rgba(170,179,214,.9);
      transform: translateY(-1px);
      transition: transform .12s ease;
    }
    details.advDetails[open] > summary::before{ transform: rotate(90deg) translateX(1px); }
    details.advDetails .advGrid{ margin-top: 10px; }
    .param{
      background: rgba(0,0,0,.16);
      border: 1px solid rgba(255,255,255,.10);
      border-radius: 14px;
      padding: 10px;
    }
    .param .head{
      display:flex;
      justify-content: space-between;
      align-items: baseline;
      gap: 10px;
      margin-bottom: 6px;
    }
    .param .name{
      font-weight: 750;
      font-size: 13px;
      display:flex;
      align-items:center;
      gap:6px;
    }
    .param .hint{
      font-size: 11px;
      color: var(--muted);
      text-align:right;
      white-space: nowrap;
    }

    /* å‚æ•°æ‚¬æµ®è¯´æ˜ï¼ˆå°é—®å·ï¼‰ */
    .help{
      width: 16px;
      height: 16px;
      border-radius: 999px;
      display:inline-flex;
      align-items:center;
      justify-content:center;
      font-size: 11px;
      font-weight: 900;
      color: #c9f3ff;
      background: rgba(90,215,255,.12);
      border: 1px solid rgba(90,215,255,.28);
      cursor: help;
      position: relative;
      flex: 0 0 auto;
    }
    .help:hover::after{
      content: attr(data-tip);
      position: absolute;
      left: 50%;
      top: 130%;
      transform: translateX(-50%);
      width: 260px;
      max-width: 70vw;
      padding: 8px 10px;
      border-radius: 12px;
      background: rgba(6,10,22,.95);
      border: 1px solid rgba(255,255,255,.12);
      color: #e9eeff;
      font-size: 12px;
      line-height: 1.35;
      box-shadow: 0 14px 40px rgba(0,0,0,.35);
      z-index: 999;
      white-space: normal;
    }
    .help:hover::before{
      content: "";
      position: absolute;
      left: 50%;
      top: 118%;
      transform: translateX(-50%);
      border: 7px solid transparent;
      border-bottom-color: rgba(6,10,22,.95);
      filter: drop-shadow(0 -1px 0 rgba(255,255,255,.10));
    }
    .param .ctrl{
      display:flex;
      gap: 10px;
      align-items:center;
    }
    input[type="range"]{
      width: 100%;
      accent-color: var(--accent);
    }
    .num{
      width: 110px;
      text-align:right;
    }
    .smallRow{
      display:flex;
      flex-wrap: wrap;
      gap:10px;
      align-items:center;
      margin-top: 8px;
    }
    .plotGrid{
      display:grid;
      /* é»˜è®¤ä¸‰åˆ—ï¼šä¸€è¡Œæœ€å¤š 3 å¼ å›¾ */
      grid-template-columns: repeat(3, 1fr);
      gap:12px;
    }
    /* å±å¹•è¾ƒçª„æ—¶è‡ªåŠ¨é™ä¸ºä¸¤åˆ—/ä¸€åˆ— */
    @media (max-width: 1300px){
      .plotGrid{grid-template-columns: repeat(2, 1fr);}
    }
    @media (max-width: 900px){
      .plotGrid{grid-template-columns: 1fr;}
    }
    .plot{
      height: 220px;
      border-radius: 14px;
      overflow:hidden;
      border: 1px solid rgba(255,255,255,.08);
      background: rgba(0,0,0,.10);
    }
    .plot.tall{height: 240px;}
    /* è¾“å‡ºç‰¹æ€§æ›´é‡è¦ï¼šè®©å®ƒåœ¨ä¸‰åˆ—å¸ƒå±€ä¸­è·¨ 2 åˆ— */
    .plot.full{grid-column: span 2; height: 260px;}
    @media (max-width: 1300px){
      .plot.full{grid-column: 1 / -1; height: 300px;}
    }

    .testList{
      display:flex;
      flex-direction: column;
      gap: 10px;
      margin-top: 8px;
    }
    .testItem{
      background: rgba(0,0,0,.16);
      border: 1px solid rgba(255,255,255,.10);
      border-radius: 12px;
      padding: 10px;
    }
    .testItem .top{
      display:flex;
      justify-content: space-between;
      align-items: center;
      gap: 10px;
      margin-bottom: 6px;
    }
    .pill{
      font-size: 11px;
      font-weight: 800;
      padding: 3px 8px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.10);
    }
    .pill.pass{background: rgba(46,229,157,.12); border-color: rgba(46,229,157,.32); color: #baffea;}
    .pill.fail{background: rgba(255,77,109,.12); border-color: rgba(255,77,109,.35); color: #ffd0d9;}
    .pill.warn{background: rgba(255,204,102,.10); border-color: rgba(255,204,102,.35); color: #ffe9b8;}
    .mono{font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;}
    .muted{color: var(--muted);}

    .watermark{
      display:inline-block;
      padding: 2px 8px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.12);
      font-weight: 900;
      letter-spacing: .6px;
      font-size: 11px;
    }
    .wm-run{background: rgba(90,215,255,.10); border-color: rgba(90,215,255,.25); color: #c9f3ff; animation: pulseRun 2.2s ease-in-out infinite;}
    .wm-hold{background: rgba(255,204,102,.10); border-color: rgba(255,204,102,.30); color: #fff0c9;}
    .wm-off{background: rgba(255,77,109,.10); border-color: rgba(255,77,109,.30); color: #ffd0d9;}
    .wm-nosig{background: rgba(180,190,220,.10); border-color: rgba(180,190,220,.20); color: #e3e9ff;}

    @keyframes pulseRun{
      0%{ box-shadow: 0 0 0 0 rgba(90,215,255,.12); }
      50%{ box-shadow: 0 0 0 4px rgba(90,215,255,.08); }
      100%{ box-shadow: 0 0 0 0 rgba(90,215,255,.12); }
    }

    .footerInfo{
      margin-top: 10px;
      font-size: 12px;
      color: var(--muted);
      line-height: 1.45;
    }
    .kbd{
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      background: rgba(255,255,255,.08);
      border: 1px solid rgba(255,255,255,.10);
      border-radius: 8px;
      padding: 2px 6px;
      font-size: 11px;
      color: #eaf2ff;
    }

    /* ------------------ ä¾§è¾¹â€œæ›´å¤šâ€é¢æ¿ï¼ˆå·¦ä¾§æ»‘å…¥ï¼‰ ------------------ */
    #moreBackdrop{
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,.45);
      backdrop-filter: blur(2px);
      z-index: 998;
      opacity: 0;
      pointer-events: none;
      transition: opacity .16s ease;
    }
    #moreBackdrop.open{
      opacity: 1;
      pointer-events: auto;
    }
    #morePanel{
      position: fixed;
      top: 0;
      left: 0;
      width: 380px;
      max-width: 92vw;
      height: 100%;
      background: rgba(11,16,32,.98);
      border-right: 1px solid rgba(255,255,255,.12);
      box-shadow: 16px 0 60px rgba(0,0,0,.45);
      z-index: 999;
      transform: translateX(-102%);
      transition: transform .18s ease;
      overflow-y: auto;
      padding: 14px 14px 18px;
    }
    #morePanel.open{ transform: translateX(0); }
    #morePanel h3{ margin: 10px 0 8px; font-size: 14px; }
    #morePanel .closeBtn{
      display: inline-flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 10px;
      cursor: pointer;
      font-size: 12px;
      color: #e9eeff;
      background: rgba(255,255,255,.06);
      border: 1px solid rgba(255,255,255,.10);
      border-radius: 10px;
      padding: 6px 10px;
    }
    #morePanel .section{
      background: rgba(0,0,0,.14);
      border: 1px solid rgba(255,255,255,.10);
      border-radius: 14px;
      padding: 10px;
      margin-bottom: 10px;
    }
    #morePanel details{
      background: rgba(0,0,0,.10);
      border: 1px solid rgba(255,255,255,.10);
      border-radius: 12px;
      padding: 8px 10px;
      margin-top: 10px;
    }
    #morePanel details > summary{
      cursor: pointer;
      font-weight: 850;
      color: #e9eeff;
      list-style: none;
    }
    #morePanel details > summary::-webkit-details-marker{display:none;}
    #morePanel details > summary::before{
      content: "â–¸";
      display: inline-block;
      margin-right: 8px;
      color: rgba(170,179,214,.90);
      transition: transform .12s ease;
    }
    #morePanel details[open] > summary::before{ transform: rotate(90deg) translateX(1px); }

    /* ------------------ é¦–æ¬¡è®¿é—®ï¼šå…³æ³¨æç¤ºå¼¹çª— ------------------ */
    #followBackdrop{
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,.55);
      backdrop-filter: blur(3px);
      z-index: 1200;
      display: none;
    }
    #followBackdrop.open{ display: block; }
    #followModal{
      position: fixed;
      z-index: 1201;
      left: 50%;
      top: 14%;
      transform: translateX(-50%);
      width: 520px;
      max-width: 92vw;
      background: linear-gradient(180deg, rgba(18,26,51,.92), rgba(15,23,48,.92));
      border: 1px solid rgba(255,255,255,.14);
      border-radius: 18px;
      box-shadow: 0 30px 80px rgba(0,0,0,.55);
      padding: 14px 14px 12px;
      display: none;
      animation: popIn .18s ease;
    }
    #followModal.open{ display: block; }
    @keyframes popIn{
      from{ transform: translateX(-50%) translateY(-6px) scale(.98); opacity: .0; }
      to{ transform: translateX(-50%) translateY(0px) scale(1); opacity: 1; }
    }
    #followModal .title{
      font-size: 14px;
      font-weight: 900;
      margin: 0 0 6px;
    }
    #followModal .actions{
      display:flex;
      justify-content: flex-end;
      gap: 10px;
      margin-top: 10px;
      flex-wrap: wrap;
    }
    #followModal .checkRow{
      display:flex;
      align-items:center;
      gap: 8px;
      color: var(--muted);
      font-size: 12px;
      margin-top: 8px;
    }
  </style>
</head>

<body>
  <div class="topbar">
    <div class="row">
      <button id="moreBtn" class="btn-ghost" title="æ‰“å¼€æ›´å¤šé¢æ¿ï¼ˆæ¨¡å‹è¯´æ˜/è¯Šæ–­/å¿«æ·é”®/æ›´æ–°æ—¥å¿—ï¼‰">â˜° æ›´å¤š</button>
      <div class="chip">
        <label>ç”µè·¯</label>
        <select id="circuitSelect">
          <option value="CE">å…±å°„ CE</option>
          <option value="CC">å…±é›† CCï¼ˆå°„æè·Ÿéšå™¨ï¼‰</option>
          <option value="CB">å…±åŸº CB</option>
        </select>
      </div>

      <div class="chip">
        <label>Power</label>
        <button id="powerBtn" class="toggle off">OFF</button>
        <label>HOLD</label>
        <button id="holdBtn" class="toggle off">OFF</button>
      </div>

      <div class="chip">
        <label>æ¨¡å‹</label>
        <select id="modelSelect">
          <option value="FAST">æ•™å­¦å¿«é€Ÿï¼ˆé»˜è®¤ï¼‰</option>
          <option value="ENH">å¢å¼ºéçº¿æ€§ï¼ˆå°½åŠ›ç¨³ï¼‰</option>
        </select>
      </div>

      <div class="chip">
        <label>ç‰µåˆ¶</label>
        <select id="constraintSelect">
          <option value="STRICT">ä¸¥æ ¼ï¼ˆä¸å…è®¸è¶…é™ï¼‰</option>
          <option value="EXPLORE">æ¢ç´¢ï¼ˆå…è®¸è¶…é™ä½†å‘Šè­¦ï¼‰</option>
        </select>
      </div>

      <div class="chip">
        <label>é¢„è®¾åœºæ™¯</label>
        <select id="presetSelect"></select>
        <button id="applyPresetBtn" class="btn-ghost">åº”ç”¨</button>
      </div>

      <button id="autoCenterBtn" class="btn-good">è‡ªåŠ¨è°ƒåç½®åˆ°å±…ä¸­</button>
      <button id="autoJustBtn" class="btn-warn">åˆšå¥½ä¸å¤±çœŸ</button>

      <div class="spacer"></div>

      <button id="resetBtn" class="btn-ghost">Reset</button>
      <button id="revertBtn" class="btn-ghost">Revert</button>
      <button id="exportBtn" class="btn-ghost">Export JSON</button>
      <button id="importBtn" class="btn-ghost">Import JSON</button>
      <input type="file" id="importFile" accept="application/json" style="display:none" />
      <button id="pngWaveBtn" class="btn-ghost">Export PNGï¼ˆæ³¢å½¢ï¼‰</button>
      <button id="pngCharBtn" class="btn-ghost">Export PNGï¼ˆç‰¹æ€§ï¼‰</button>
    </div>

    <div id="globalBanner" class="banner"></div>

    <div class="kpis" id="kpiPanel">
      <!-- filled by JS -->
    </div>
  </div>

  <div class="layout">
    <div class="left">
      <div class="card">
        <h3>åŠ¨æ€ç”µè·¯ç¤ºæ„å›¾ï¼ˆSVGï¼‰ <span id="wmTag" class="watermark wm-nosig">NO SIGNAL</span></h3>
        <div class="subtle">æ•™æé£æ ¼ç”µè·¯å›¾ + å…ƒä»¶å‚æ•° + Q ç‚¹æ ‡æ³¨ï¼›<span class="kbd">HOLD</span> æ—¶å†»ç»“ç”»é¢ï¼ˆå‚æ•°å¯æ”¹ä½†ä¸åº”ç”¨ï¼‰ã€‚</div>
        <div class="svgWrap" id="svgWrap"></div>
      </div>

      <div class="card">
        <h3>å‚æ•°ï¼ˆä»…æ˜¾ç¤ºå½“å‰ç”µè·¯ç›¸å…³é¡¹ï¼‰</h3>
        <div class="subtle">å†…éƒ¨ç»Ÿä¸€ SI å•ä½è®¡ç®—ï¼›ç•Œé¢è‡ªåŠ¨è¿›è¡Œ mV/ÂµA/kÎ© å‹å¥½æ˜¾ç¤ºï¼›Ui æœ€å¤§å…è®¸å€¼ Ui<sub>max</sub> é€šè¿‡æ•°å€¼æ‰«æ/äºŒåˆ†æ±‚è§£å¾—åˆ°ã€‚</div>
        <div class="subtle" style="margin-top:6px;">å¿«æ·é”®ï¼š<span class="kbd">â†</span>/<span class="kbd">â†’</span> å¾®è°ƒ VBQï¼Œ<span class="kbd">â†‘</span>/<span class="kbd">â†“</span> å¾®è°ƒ Uiï¼ˆä¸æŠ¢å è¾“å…¥æ¡†ç„¦ç‚¹ï¼‰ã€‚</div>
        <div id="pendingHint" class="banner warn" style="display:none;margin-top:10px;">
          å·²å†»ç»“ï¼ˆHOLDï¼‰ï¼šä½ ä¿®æ”¹äº†å‚æ•°ï¼Œä½†å›¾åƒä¸ä¼šæ›´æ–°ã€‚è§£é™¤ HOLD åå°†ç«‹å³æŒ‰å½“å‰å‚æ•°åˆ·æ–°ã€‚
        </div>
        <div class="paramGrid" id="paramPanel" style="margin-top:10px;"></div>
      </div>
    </div>

    <div class="right">
      <div class="card">
        <h3>å›¾è¡¨åŒºï¼ˆ5 å¼ ï¼Œä¸‰åˆ—å¸ƒå±€ï¼‰</h3>
        <div class="subtle">ui(t)ã€uo(t)ï¼ˆæ”¯æŒå«ç›´æµ/ACè€¦åˆï¼‰ã€è¾“å…¥ç‰¹æ€§ + Q ç‚¹ã€è¾“å‡ºç‰¹æ€§æ— + ç›´æµ/äº¤æµè´Ÿè½½çº¿ + è½¨è¿¹ã€ä¼ è¾“ç‰¹æ€§ uo-uiï¼ˆå«çº¿æ€§æ®µæç¤ºï¼‰ã€‚</div>
        <div class="plotGrid" style="margin-top:10px;">
          <div id="plotUi" class="plot"></div>
          <div id="plotUo" class="plot"></div>
          <div id="plotIn" class="plot tall"></div>
          <div id="plotTransfer" class="plot tall"></div>
          <div id="plotOut" class="plot full"></div>
        </div>
      </div>
    </div>
  </div>

  <!-- å·¦ä¾§æ»‘å…¥ï¼šæ›´å¤š / æ¨¡å‹è¯´æ˜ / è‡ªæµ‹è¯Šæ–­ / æ›´æ–°æ—¥å¿— -->
  <div id="moreBackdrop" aria-hidden="true"></div>
  <aside id="morePanel" aria-label="æ›´å¤šä¿¡æ¯é¢æ¿">
    <button id="closeMoreBtn" class="closeBtn">âœ• å…³é—­</button>

    <div class="section">
      <div class="subtle"><b>ä½œè€…</b>ï¼šBç«™ @ä¸è¸©ç™½å—çš„é»‘å—</div>
      <div class="subtle">ä¸»é¡µï¼š<a href="https://space.bilibili.com/269896665" target="_blank" rel="noopener">https://space.bilibili.com/269896665</a></div>
    </div>

    <details open>
      <summary>å…³äºæœ¬å·¥å…·</summary>
      <div class="footerInfo">
        <ul>
          <li>æœ¬é¡µé¢ä¸º<b>æ•™å­¦è¿‘ä¼¼æ¨¡å‹</b>ï¼ˆä¸æ˜¯ SPICEï¼‰ï¼Œç›®æ ‡æ˜¯ç°è±¡æ­£ç¡®ã€ç¨³å®šã€å¯è§£é‡Šã€‚</li>
          <li>æ”¯æŒä¸‰ç”µè·¯ï¼š<b>å…±å°„ CE / å…±é›† CCï¼ˆå°„éšï¼‰/ å…±åŸº CB</b>ï¼Œå¹¶å¯è§‚å¯Ÿ Q ç‚¹ã€ç‰¹æ€§æ›²çº¿ã€æ³¢å½¢ã€è½¨è¿¹ä¸å¤±çœŸã€‚</li>
          <li>çŠ¶æ€æœºï¼šPower OFF æ°¸è¿œä¼˜å…ˆï¼›HOLD å†»ç»“å…¨éƒ¨å›¾åƒä¸ Q ç‚¹ã€‚</li>
        </ul>
      </div>
    </details>

    <details>
      <summary>æ¨¡å‹è¯´æ˜ / ç®€åŒ–å‡è®¾</summary>
      <div class="footerInfo">
        <ul>
          <li><b>è¾“å…¥ç‰¹æ€§</b>ï¼šé‡‡ç”¨æŒ‡æ•°å…³ç³»ï¼ˆç±»ä¼¼äºŒæç®¡æ–¹ç¨‹ï¼‰è®¡ç®— IBâ€“VBE / IEâ€“VEBã€‚</li>
          <li><b>è¾“å‡ºç‰¹æ€§æ—</b>ï¼šç®€åŒ– ICâ€“VCE æ›²çº¿æ—ï¼ˆå¸¦ Early è¿‘ä¼¼ VAï¼Œå¹¶å«é¥±å’Œâ€œæ‹ç‚¹â€ï¼‰ã€‚</li>
          <li><b>è€¦åˆç”µå®¹</b>ï¼šDC è§†ä¸ºå¼€è·¯ï¼›AC è§†ä¸ºçŸ­è·¯ï¼ˆç”¨å»ç›´æµç”µæµçš„è¿‘ä¼¼æ–¹å¼ä¿è¯å¹³å‡å€¼ä¸ Q ç‚¹ä¸€è‡´ï¼‰ã€‚</li>
          <li><b>å‰Šé¡¶</b>ï¼šè§¦åŠæˆªæ­¢ï¼ˆICâ‰ˆ0ï¼‰æˆ–é¥±å’Œï¼ˆVCEâ‰ˆVCE(sat)ï¼‰è‡ªåŠ¨é™å¹…ï¼Œå¯æ¼”ç¤ºå•è¾¹/åŒè¾¹å‰Šé¡¶ä¸â€œå…ˆæˆªæ­¢/å…ˆé¥±å’Œâ€ã€‚</li>
          <li><b>å¢å¼ºæ¨¡å¼</b>ï¼šå°è¯•æ›´å¼ºéçº¿æ€§æ±‚è§£ï¼›è‹¥å‡ºç°å¼‚å¸¸ä¼šè‡ªåŠ¨é™çº§å›å¿«é€Ÿæ¨¡å¼å¹¶æç¤ºã€‚</li>
        </ul>
      </div>
    </details>

    <details>
      <summary>è¯Šæ–­ / è‡ªæµ‹</summary>
      <div class="subtle">é¡µé¢åŠ è½½åè‡ªåŠ¨æ‰§è¡Œ runSelfTests()ï¼šçŠ¶æ€æœºã€DC æ±‚è§£ã€å‰Šé¡¶æ¼”åŒ–ã€åŠ¨æ€ç‰µåˆ¶ã€ä¸€è‡´æ€§ä¸æ€§èƒ½ç­‰ã€‚</div>
      <div class="testList" id="testPanel"></div>
      <div style="height:8px"></div>
      <div class="subtle"><b>å½“å‰è¯Šæ–­ï¼ˆè¿è¡Œä¸­ï¼‰</b></div>
      <div id="liveDiag" class="subtle"></div>
    </details>

    <details>
      <summary>å¿«æ·é”®</summary>
      <div class="footerInfo">
        <ul>
          <li><span class="kbd">â†</span>/<span class="kbd">â†’</span>ï¼šå¾®è°ƒ VBQï¼ˆåç½®ï¼‰</li>
          <li><span class="kbd">â†‘</span>/<span class="kbd">â†“</span>ï¼šå¾®è°ƒ Uiï¼ˆè¾“å…¥å¹…åº¦ï¼‰</li>
          <li>åœ¨è¾“å…¥æ¡†/ä¸‹æ‹‰æ¡†èšç„¦æ—¶ï¼Œå¿«æ·é”®ä¸ä¼šç”Ÿæ•ˆï¼ˆé¿å…è¯¯æ“ä½œï¼‰ã€‚</li>
        </ul>
      </div>
    </details>

    <details>
      <summary>ç‰ˆæœ¬æ›´æ–°æ—¥å¿—</summary>
      <div class="footerInfo">
        <ul>
          <li>v1.0ï¼šåŸºç¡€ CE/CC/CB + Q ç‚¹ + 5 å›¾ + çŠ¶æ€æœº + è‡ªæµ‹ã€‚</li>
          <li>v1.1ï¼šåŠ å…¥ Ui_max åŠ¨æ€ç‰µåˆ¶ï¼ˆæ•°å€¼æ‰«æ/äºŒåˆ†ï¼‰ä¸ä¸¥æ ¼/æ¢ç´¢æ¨¡å¼ã€‚</li>
          <li>v1.2ï¼šåŠ å…¥è¾“å‡ºç‰¹æ€§è½¨è¿¹ä¸ä¼ è¾“ç‰¹æ€§çº¿æ€§æ®µæç¤ºã€‚</li>
          <li>v1.3ï¼šåŠ å…¥é”®ç›˜å¾®è°ƒï¼ˆVBQ/Uiï¼‰ã€ä¸‰åˆ—å›¾è¡¨å¸ƒå±€ã€æ›´å¤šé¢æ¿æ”¶çº³æ¨¡å‹è¯´æ˜ä¸è¯Šæ–­ã€‚</li>
          <li>v1.4ï¼šç”µè·¯å›¾å‡çº§ä¸ºâ€œè¯¾æœ¬é£æ ¼â€SVGï¼›æ–°å¢â€œç‚¹å‡»è¾“å‡ºç‰¹æ€§å›¾è°ƒ VBQï¼ˆè¿‘ä¼¼ï¼‰â€ä¸é¦–æ¬¡è®¿é—®å…³æ³¨å¼¹çª—ï¼›å¢å¼ºå›¾è¡¨è‡ªé€‚åº” resize ä¸å‚æ•°æ‚¬æµ®è¯´æ˜ã€‚</li>
        </ul>
      </div>
    </details>
  </aside>

  <!-- é¦–æ¬¡è®¿é—®æç¤ºï¼šå…³æ³¨ä½œè€…ï¼ˆå¯é€‰æ‹©ä¸å†æé†’ï¼‰ -->
  <div id="followBackdrop" aria-hidden="true"></div>
  <div id="followModal" role="dialog" aria-modal="true" aria-label="å…³æ³¨æç¤º">
    <div class="title">ğŸ“Œ ç¬¬ä¸€æ¬¡æ¥ï¼Ÿæ¬¢è¿å…³æ³¨ä½œè€… B ç«™</div>
    <div class="subtle">ä½œè€…ï¼šBç«™ <b>@ä¸è¸©ç™½å—çš„é»‘å—</b>ã€‚å…³æ³¨å¯è·å¾—æ›´æ–°ã€è¯¾å ‚ä¾‹é¢˜ä¸æ›´å¤šæ¨¡ç”µæ•™å­¦å†…å®¹ã€‚</div>
    <div class="checkRow">
      <input id="dontRemindFollow" type="checkbox" />
      <label for="dontRemindFollow">ä¸å†æé†’</label>
    </div>
    <div class="actions">
      <button id="followGoBtn" class="btn-good">å»å…³æ³¨</button>
      <button id="followOkBtn" class="btn-ghost">ç¡®å®š</button>
    </div>
  </div>

  <div class="footerInfo" style="padding: 0 12px 14px;">
    <span class="muted">Â© æ•™å­¦æ¼”ç¤ºå·¥å…·ï¼ˆæ•™å­¦è¿‘ä¼¼æ¨¡å‹ï¼‰ | ä½œè€… Bç«™ @ä¸è¸©ç™½å—çš„é»‘å—ï¼š</span>
    <a href="https://space.bilibili.com/269896665" target="_blank" rel="noopener">ç‚¹å‡»è·³è½¬</a>
  </div>

<script>
/*
 * ============================================================
 *  BJT ä¸‰åŸºæœ¬æ”¾å¤§ç”µè·¯äº¤äº’æ•™å­¦å·¥å…·ï¼ˆå•æ–‡ä»¶ / Plotly CDNï¼‰
 *  - ç”µè·¯ï¼šCE / CC(å°„éš) / CB
 *  - å¼ºåˆ¶ï¼šSVG ç”µè·¯å›¾ + Q ç‚¹ + 5 å¼ å›¾ + Power/HOLD çŠ¶æ€æœº
 *  - å¼ºåˆ¶ï¼šå‚æ•°ç‰µåˆ¶ï¼ˆUi_max æ•°å€¼æ‰«æ/äºŒåˆ†ï¼‰+ ä¸¥æ ¼/æ¢ç´¢æ¨¡å¼
 *  - å¼ºåˆ¶ï¼šçº¯å‡½æ•°ç»“æ„ + è‡ªæµ‹ + å¤±è´¥é™çº§ï¼ˆä¸å´©æºƒï¼‰
 * ============================================================
 */

/* ----------------------------- å·¥å…·ï¼šæ·±æ‹·è´ & æ•°å­¦ ----------------------------- */
const deepCopy = (x)=> JSON.parse(JSON.stringify(x));
const clamp = (x, a, b)=> Math.max(a, Math.min(b, x));
const isFiniteNum = (x)=> Number.isFinite(x) && !Number.isNaN(x);
const lerp = (a,b,t)=> a+(b-a)*t;
const parallel = (R1,R2)=>{
  if (!isFinite(R1) || R1<=0) return R2;
  if (!isFinite(R2) || R2<=0) return R1;
  return 1/(1/R1 + 1/R2);
};
const nowMs = ()=> (performance && performance.now) ? performance.now() : Date.now();

/* ----------------------------- å•ä½æ˜¾ç¤ºï¼šå‹å¥½æ ¼å¼ ----------------------------- */
function formatSI(value, unit, digits=3){
  if (!isFiniteNum(value)) return "â€”";
  const abs = Math.abs(value);
  const prefixes = [
    {p:1e-12, s:"p"}, {p:1e-9, s:"n"}, {p:1e-6, s:"Âµ"}, {p:1e-3, s:"m"},
    {p:1, s:""}, {p:1e3, s:"k"}, {p:1e6, s:"M"}, {p:1e9, s:"G"}
  ];
  let chosen = prefixes[4];
  for (let i=0;i<prefixes.length;i++){
    if (abs>=prefixes[i].p) chosen = prefixes[i];
  }
  if (abs===0) chosen = prefixes[4];
  const v = value / chosen.p;
  const d = (Math.abs(v) < 10) ? digits : (Math.abs(v) < 100 ? Math.max(2,digits-1) : Math.max(1,digits-2));
  return `${v.toFixed(d)} ${chosen.s}${unit}`;
}
function fmtOhm(R){ return formatSI(R, "Î©"); }
function fmtV(v){ return formatSI(v, "V"); }
function fmtA(i){ return formatSI(i, "A"); }
function fmtW(p){ return formatSI(p, "W"); }
function fmtHz(f){ return formatSI(f, "Hz"); }

/* ----------------------------- ç‰©ç†å¸¸æ•° / é»˜è®¤å™¨ä»¶ ----------------------------- */
const PHYS = {
  VT: 0.02585,
  IS: 1e-15,
  VBE_CUTOFF: 0.50
};

/* ----------------------------- çŠ¶æ€æœºï¼ˆPower/HOLDï¼‰ ----------------------------- */
function fsmTransition(state, event){
  const s = {...state};
  if (event.type==="SET_POWER"){
    s.powerSwitch = !!event.value;
  }
  if (event.type==="SET_HOLD"){
    s.holdSwitch = !!event.value;
  }
  if (!s.powerSwitch){
    s.mode = "OFF";
    return s;
  }
  s.mode = s.holdSwitch ? "HOLD" : "RUN";
  return s;
}

/* ----------------------------- BJT æ¨¡å‹ï¼ˆç®€åŒ–ï¼‰ ----------------------------- */
function bjtIcFromVbeVce(params, vbe, vce, modelMode){
  const VT = PHYS.VT;
  const IS = PHYS.IS;
  const VA = Math.max(1, params.VA || 1e9);
  const arg = clamp(vbe/VT, -50, 50);
  let ic = IS * Math.exp(arg);
  if (modelMode==="ENH"){
    const vceEff = Math.max(0, vce);
    ic *= (1 + vceEff/VA);
  }
  return ic;
}

function outputIcCurveFromIb(params, ib, vce){
  const beta = Math.max(1, params.beta);
  const VA = Math.max(1, params.VA || 1e9);
  const VCEsat = Math.max(0.02, params.VCEsat);
  const ic0 = beta * Math.max(0, ib);
  const knee = VCEsat + 0.06;
  if (vce <= 0) return 0;
  if (vce < knee){
    return ic0 * (vce / knee);
  }
  return ic0 * (1 + (vce - knee)/VA);
}

/* ----------------------------- æ ¸å¿ƒçº¯å‡½æ•° 1ï¼šDC æ±‚è§£ ----------------------------- */
function solveDC(params, circuitType){
  const p = deepCopy(params);
  const diag = [];
  const out = {
    ok:false, region:"unknown",
    VCEQ:NaN, ICQ:NaN, IBQ:NaN, IEQ:NaN,
    VBEQ:NaN, VC:NaN, VE:NaN, VB:NaN,
    diagnostics: diag
  };
  try{
    const modelMode = "ENH";
    const VCC = p.VCC;
    const beta = Math.max(1, p.beta);
    const VCEsat = Math.max(0.02, p.VCEsat);
    function bisectIC(getMid, hi0){
      let lo = 0;
      let hi = hi0;
      let a = getMid(lo); let fa = a.icm - lo;
      let b = getMid(hi); let fb = b.icm - hi;
      let guard=0;
      while (fb > 0 && guard < 30){
        hi *= 1.7;
        if (hi > Math.max(2, p.IC_max*20)) break;
        b = getMid(hi);
        fb = b.icm - hi;
        guard++;
      }
      if (!(fa>=0 && fb<=0)){
        const icGuess = clamp(a.icm, 0, hi);
        const m = getMid(icGuess);
        return {ic: icGuess, mid:m, bracketed:false};
      }
      let mid = 0, m=null;
      for (let i=0;i<42;i++){
        mid = 0.5*(lo+hi);
        m = getMid(mid);
        const fm = m.icm - mid;
        if (!isFiniteNum(fm)) { hi = mid; continue; }
        if (fm > 0) lo = mid;
        else hi = mid;
      }
      return {ic: 0.5*(lo+hi), mid: getMid(0.5*(lo+hi)), bracketed:true};
    }
    if (circuitType==="CE"){
      const RC = Math.max(1, p.RC);
      const RE = Math.max(0, p.RE);
      const VB = p.VBQ;
      out.VB = VB;
      function getMid(ic){
        const ib = ic/beta;
        const ie = ic + ib;
        const ve = (RE>0) ? ie*RE : 0;
        const vc = VCC - ic*RC;
        const vce = vc - ve;
        const vbe = VB - ve;
        const icm = bjtIcFromVbeVce(p, vbe, vce, modelMode);
        return {ib, ie, ve, vc, vce, vbe, icm};
      }
      const hi0 = Math.min(Math.max(0.03, p.IC_max*2), 0.5);
      let sol = bisectIC(getMid, hi0);
      let ic = sol.ic;
      let m = sol.mid;
      if (m.vce < VCEsat){
        const ib = ic/beta;
        const ie = ic + ib;
        const ve = (RE>0) ? ie*RE : 0;
        const vc = ve + VCEsat;
        ic = Math.max(0, (VCC - vc)/RC);
        m = getMid(ic);
        out.region = "saturation";
      } else if (m.vbe < PHYS.VBE_CUTOFF || ic < 1e-9){
        ic = 0;
        m = getMid(ic);
        out.region = "cutoff";
      } else {
        out.region = "active";
      }
      out.ICQ = ic;
      out.IBQ = ic/beta;
      out.IEQ = out.ICQ + out.IBQ;
      out.VE = (RE>0)? out.IEQ*RE : 0;
      out.VC = VCC - out.ICQ*RC;
      out.VCEQ = out.VC - out.VE;
      out.VBEQ = out.VB - out.VE;
    }
    if (circuitType==="CC"){
      const RE = Math.max(1, p.RE);
      const VB = p.VBQ;
      out.VB = VB;
      function getMid(ic){
        const ib = ic/beta;
        const ie = ic + ib;
        const ve = ie*RE;
        const vce = VCC - ve;
        const vbe = VB - ve;
        const icm = bjtIcFromVbeVce(p, vbe, vce, modelMode);
        return {ib, ie, ve, vc:VCC, vce, vbe, icm};
      }
      const hi0 = Math.min(Math.max(0.02, p.IC_max*2), 0.5);
      let sol = bisectIC(getMid, hi0);
      let ic = sol.ic;
      let m = sol.mid;
      if (m.vce < VCEsat){
        const ve = VCC - VCEsat;
        const ie = ve/RE;
        ic = ie / (1 + 1/beta);
        m = getMid(ic);
        out.region = "saturation";
      } else if (m.vbe < PHYS.VBE_CUTOFF || ic < 1e-9){
        ic = 0; m = getMid(ic);
        out.region = "cutoff";
      } else out.region = "active";
      out.ICQ = ic;
      out.IBQ = ic/beta;
      out.IEQ = out.ICQ + out.IBQ;
      out.VE = out.IEQ*RE;
      out.VC = VCC;
      out.VCEQ = out.VC - out.VE;
      out.VBEQ = out.VB - out.VE;
    }
    if (circuitType==="CB"){
      const RC = Math.max(1, p.RC);
      const RE = Math.max(1, p.RE);
      const VB = p.VBQ;
      out.VB = VB;
      function getMid(ic){
        const ib = ic/beta;
        const ie = ic + ib;
        const ve = ie*RE;
        const vc = VCC - ic*RC;
        const vce = vc - ve;
        const vbe = VB - ve;
        const icm = bjtIcFromVbeVce(p, vbe, vce, modelMode);
        return {ib, ie, ve, vc, vce, vbe, icm};
      }
      const hi0 = Math.min(Math.max(0.03, p.IC_max*2), 0.5);
      let sol = bisectIC(getMid, hi0);
      let ic = sol.ic;
      let m = sol.mid;
      if (m.vce < VCEsat){
        const vc = m.ve + VCEsat;
        ic = Math.max(0, (VCC - vc)/RC);
        m = getMid(ic);
        out.region = "saturation";
      } else if (m.vbe < PHYS.VBE_CUTOFF || ic < 1e-9){
        ic = 0; m = getMid(ic);
        out.region = "cutoff";
      } else out.region = "active";
      out.ICQ = ic;
      out.IBQ = ic/beta;
      out.IEQ = out.ICQ + out.IBQ;
      out.VE = out.IEQ*RE;
      out.VC = VCC - out.ICQ*RC;
      out.VCEQ = out.VC - out.VE;
      out.VBEQ = out.VB - out.VE;
    }
    const fields = ["VCEQ","ICQ","IBQ","IEQ","VBEQ","VC","VE"];
    for (const k of fields){
      if (!isFiniteNum(out[k])) diag.push(`DC: ${k} éæœ‰é™å€¼ï¼ˆNaN/Infï¼‰`);
    }
    if (out.ICQ < -1e-12) diag.push("DC: ICQ<0ï¼ˆè¢«å¤¹æ–­ï¼‰");
    if (out.VCEQ < -0.5) diag.push("DC: VCEQ<0ï¼ˆå‚æ•°å¯èƒ½æç«¯ï¼‰");
    out.ok = diag.length===0;
    if (!out.ok) out.region = "invalid";
    return out;
  } catch(e){
    out.ok = false;
    out.region = "invalid";
    out.diagnostics.push(`DC æ±‚è§£å¼‚å¸¸ï¼š${String(e)}`);
    return out;
  }
}

/* ----------------------------- æ ¸å¿ƒçº¯å‡½æ•° 2ï¼šç‰¹æ€§æ›²çº¿ ----------------------------- */
function genCharacteristics(params, circuitType, dc){
  const p = deepCopy(params);
  const beta = Math.max(1, p.beta);
  const VCC = p.VCC;
  const VCEsat = Math.max(0.02, p.VCEsat);
  const inX = [];
  const inY = [];
  let inTitle = "";
  let inXLabel = "";
  let inYLabel = "";
  let qx = NaN, qy = NaN;
  const cbUnified = !!p.cbUnifiedView;
  const vMin = 0.48, vMax = 0.88;
  const N = 180;
  for (let i=0;i<N;i++){
    const v = lerp(vMin, vMax, i/(N-1));
    if (circuitType==="CB" && !cbUnified){
      const ie = (1 + 1/beta) * PHYS.IS * Math.exp(clamp(v/PHYS.VT, -50, 50));
      inX.push(v);
      inY.push(ie);
    } else {
      const ic = PHYS.IS * Math.exp(clamp(v/PHYS.VT, -50, 50));
      const ib = ic / beta;
      inX.push(v);
      inY.push(ib);
    }
  }
  if (circuitType==="CB" && !cbUnified){
    inTitle = "è¾“å…¥ç‰¹æ€§ï¼šIE â€“ VEBï¼ˆå…±åŸºæ›´è‡ªç„¶è§†è§’ï¼‰";
    inXLabel = "VEB (V)";
    inYLabel = "IE (A)";
    qx = dc.VBEQ;
    qy = dc.IEQ;
  } else {
    inTitle = "è¾“å…¥ç‰¹æ€§ï¼šIB â€“ VBE";
    inXLabel = "VBE (V)";
    inYLabel = "IB (A)";
    qx = dc.VBEQ;
    qy = dc.IBQ;
  }
  const outCurves = [];
  const ibQ = Math.max(0, dc.IBQ);
  const ibSet = [
    0,
    ibQ*0.25,
    ibQ*0.5,
    ibQ,
    ibQ*2,
    ibQ*4
  ].map(x=> +x.toFixed(12));
  const vceX = [];
  const VCEmax = Math.max(0.2, VCC);
  const M = 220;
  for (let i=0;i<M;i++){
    vceX.push(lerp(0, VCEmax, i/(M-1)));
  }
  for (const ib of ibSet){
    const y = vceX.map(vce=> outputIcCurveFromIb(p, ib, vce));
    outCurves.push({ib, vce: vceX, ic: y});
  }
  function dcLoadLinePoints(){
    const xs = [0, VCC];
    const ys = [];
    for (const VCE of xs){
      let denom = 1e-9;
      if (circuitType==="CE" || circuitType==="CB"){
        denom = Math.max(1, p.RC) + (Math.max(0, p.RE) * (1 + 1/p.beta));
      } else if (circuitType==="CC"){
        denom = (Math.max(1, p.RE) * (1 + 1/p.beta));
      }
      const ic = (VCC - VCE) / denom;
      ys.push(Math.max(0, ic));
    }
    return {VCE: xs, IC: ys};
  }
  function acLoadLinePoints(){
    const xs = [];
    const ys = [];
    const n=2;
    let Rac = 1e9;
    if (circuitType==="CE" || circuitType==="CB"){
      const Rcol = parallel(p.RC, p.RL);
      Rac = Rcol + (Math.max(0, p.RE) * (1 + 1/p.beta));
    } else if (circuitType==="CC"){
      const Rem = parallel(p.RE, p.RL);
      Rac = Rem * (1 + 1/p.beta);
    }
    for (let i=0;i<n;i++){
      const VCE = (i===0) ? 0 : VCC;
      const IC = dc.ICQ + (dc.VCEQ - VCE)/Math.max(1e-6, Rac);
      xs.push(VCE);
      ys.push(Math.max(0, IC));
    }
    return {VCE: xs, IC: ys, Rac};
  }
  const regions = {
    saturation: {x0:0, x1:VCEsat},
    cutoffIC: Math.max(1e-9, dc.ICQ*0.06)
  };
  const acLL = acLoadLinePoints();
  const Rac = acLL.Rac;
  const VCE_cutoff = dc.VCEQ + dc.ICQ * Rac;
  const VCE_sat = VCEsat;
  const marginToCutoff = Math.max(0, VCE_cutoff - dc.VCEQ);
  const marginToSat = Math.max(0, dc.VCEQ - VCE_sat);
  return {
    inputCurve: {x: inX, y: inY, title: inTitle, xLabel: inXLabel, yLabel: inYLabel, q: {x: qx, y: qy}},
    outputCurves: {vceX, curves: outCurves, ibSet},
    loadLines: {dc: dcLoadLinePoints(), ac: acLL, margins: {marginToCutoff, marginToSat, VCE_cutoff}},
    regions,
    notes: []
  };
}

/* ----------------------------- æ±‚è§£ç¬æ—¶ç‚¹ï¼ˆç”¨äºæ³¢å½¢/è½¨è¿¹ï¼‰ ----------------------------- */
function solveInstant(params, circuitType, dc, input, modelMode, options){
  const p = params;
  const beta = Math.max(1, p.beta);
  const VCC = p.VCC;
  const VCEsat = Math.max(0.02, p.VCEsat);
  const RL = (options && options.useRL) ? p.RL : Infinity;
  function robustSolveIC(getMid, hi0){
    let lo=0, hi=hi0;
    let mLo=getMid(lo), fLo=mLo.icm-lo;
    let mHi=getMid(hi), fHi=mHi.icm-hi;
    let guard=0;
    while (fHi>0 && guard<25){
      hi*=1.7;
      if (hi>Math.max(2, p.IC_max*30)) break;
      mHi=getMid(hi); fHi=mHi.icm-hi;
      guard++;
    }
    if (!(fLo>=0 && fHi<=0)){
      const icGuess = clamp(mLo.icm, 0, hi);
      return {ic: icGuess, m: getMid(icGuess), ok:false};
    }
    let mid=0, m=null;
    for (let i=0;i<34;i++){
      mid=0.5*(lo+hi);
      m=getMid(mid);
      const f=m.icm-mid;
      if (!isFiniteNum(f)){ hi=mid; continue; }
      if (f>0) lo=mid; else hi=mid;
    }
    const ic=0.5*(lo+hi);
    return {ic, m:getMid(ic), ok:true};
  }
  if (circuitType==="CE"){
    const RC = Math.max(1, p.RC);
    const RE = Math.max(0, p.RE);
    const VB = input.VB;
    const VCQ = dc.VC;
    const invRC = 1/RC;
    const invRL = (isFinite(RL) && RL>0) ? 1/RL : 0;
    const denom = invRC + invRL;
    function nodeVCFromIC(ic){
      if (invRL===0) return VCC - ic*RC;
      return (VCC*invRC + VCQ*invRL - ic) / denom;
    }
    function getMid(ic){
      const ib = ic/beta;
      const ie = ic+ib;
      const ve = (RE>0) ? ie*RE : 0;
      const vc = nodeVCFromIC(ic);
      const vce = vc - ve;
      const vbe = VB - ve;
      const icm = bjtIcFromVbeVce(p, vbe, vce, modelMode);
      return {ib, ie, ve, vc, vce, vbe, icm};
    }
    const hi0 = Math.min(Math.max(0.02, p.IC_max*2), 0.6);
    let sol = robustSolveIC(getMid, hi0);
    let ic = sol.ic;
    let m = sol.m;
    if (m.vce < VCEsat){
      const ib = ic/beta;
      const ie = ic+ib;
      const ve = (RE>0)? ie*RE : 0;
      const vc = ve + VCEsat;
      const iRC = (VCC - vc)/RC;
      const iRL = (invRL===0) ? 0 : (vc - VCQ)/RL;
      ic = Math.max(0, iRC - iRL);
      m = getMid(ic);
      return {ic, ib:ic/beta, ie:ic+ic/beta, ve:m.ve, vc, vce:vc-m.ve, vbe:VB-m.ve, region:"saturation", solverOk: sol.ok};
    }
    if (m.vbe < PHYS.VBE_CUTOFF || ic < 1e-9){
      ic = 0;
      m = getMid(ic);
      return {ic:0, ib:0, ie:0, ve:m.ve, vc:m.vc, vce:m.vce, vbe:m.vbe, region:"cutoff", solverOk: sol.ok};
    }
    return {ic, ib:m.ib, ie:m.ie, ve:m.ve, vc:m.vc, vce:m.vce, vbe:m.vbe, region:"active", solverOk: sol.ok};
  }
  if (circuitType==="CC"){
    const RE = Math.max(1, p.RE);
    const VB = input.VB;
    const VEQ = dc.VE;
    const invRE = 1/RE;
    const invRL = (isFinite(RL) && RL>0) ? 1/RL : 0;
    const denom = invRE + invRL;
    function veFromIE(ie){
      if (invRL===0) return ie*RE;
      return (ie + VEQ*invRL) / denom;
    }
    function getMid(ic){
      const ib = ic/beta;
      const ie = ic+ib;
      const ve = veFromIE(ie);
      const vce = VCC - ve;
      const vbe = VB - ve;
      const icm = bjtIcFromVbeVce(p, vbe, vce, modelMode);
      return {ib, ie, ve, vc:VCC, vce, vbe, icm};
    }
    const hi0 = Math.min(Math.max(0.02, p.IC_max*2), 0.6);
    let sol = robustSolveIC(getMid, hi0);
    let ic = sol.ic;
    let m = sol.m;
    if (m.vce < VCEsat){
      const ve = VCC - VCEsat;
      const ie = ve*invRE + (invRL===0 ? 0 : (ve - VEQ)*invRL);
      ic = ie / (1 + 1/beta);
      m = getMid(ic);
      return {ic, ib:ic/beta, ie, ve, vc:VCC, vce:VCC-ve, vbe:VB-ve, region:"saturation", solverOk: sol.ok};
    }
    if (m.vbe < PHYS.VBE_CUTOFF || ic < 1e-9){
      return {ic:0, ib:0, ie:0, ve:0, vc:VCC, vce:VCC, vbe:VB, region:"cutoff", solverOk: sol.ok};
    }
    return {ic, ib:m.ib, ie:m.ie, ve:m.ve, vc:VCC, vce:m.vce, vbe:m.vbe, region:"active", solverOk: sol.ok};
  }
  if (circuitType==="CB"){
    const RC = Math.max(1, p.RC);
    const VB = p.VBQ;
    const VE = input.VE;
    const VCQ = dc.VC;
    const invRC = 1/RC;
    const invRL = (isFinite(RL) && RL>0) ? 1/RL : 0;
    const denom = invRC + invRL;
    function nodeVCFromIC(ic){
      if (invRL===0) return VCC - ic*RC;
      return (VCC*invRC + VCQ*invRL - ic) / denom;
    }
    function getMid(ic){
      const ib = ic/beta;
      const ie = ic+ib;
      const vc = nodeVCFromIC(ic);
      const vce = vc - VE;
      const vbe = VB - VE;
      const icm = bjtIcFromVbeVce(p, vbe, vce, modelMode);
      return {ib, ie, ve:VE, vc, vce, vbe, icm};
    }
    const hi0 = Math.min(Math.max(0.02, p.IC_max*2), 0.6);
    let sol = robustSolveIC(getMid, hi0);
    let ic = sol.ic;
    let m = sol.m;
    if (m.vce < VCEsat){
      const vc = VE + VCEsat;
      const iRC = (VCC - vc)/RC;
      const iRL = (invRL===0) ? 0 : (vc - VCQ)/RL;
      ic = Math.max(0, iRC - iRL);
      m = getMid(ic);
      return {ic, ib:ic/beta, ie:ic+ic/beta, ve:VE, vc, vce:vc-VE, vbe:VB-VE, region:"saturation", solverOk: sol.ok};
    }
    if (m.vbe < PHYS.VBE_CUTOFF || ic < 1e-9){
      return {ic:0, ib:0, ie:0, ve:VE, vc:nodeVCFromIC(0), vce:nodeVCFromIC(0)-VE, vbe:VB-VE, region:"cutoff", solverOk: sol.ok};
    }
    return {ic, ib:m.ib, ie:m.ie, ve:VE, vc:m.vc, vce:m.vce, vbe:m.vbe, region:"active", solverOk: sol.ok};
  }
  return {ic:0, ib:0, ie:0, ve:0, vc:0, vce:0, vbe:0, region:"unknown", solverOk:false};
}

/* ----------------------------- æ ¸å¿ƒçº¯å‡½æ•° 3ï¼šæ³¢å½¢ç”Ÿæˆ ----------------------------- */
function genWaveforms(params, circuitType, dc, modelMode){
  const p = deepCopy(params);
  const f = Math.max(0.1, p.f);
  const w = 2*Math.PI*f;
  const Ui = Math.max(0, p.Ui);
  const cycles = Math.max(1, Math.round(p.cycles || 2));
  const n = Math.max(220, Math.round(p.samples || 420));
  const T = 1/f;
  const tEnd = cycles*T;
  const t = new Array(n);
  const ui = new Array(n);
  const uo = new Array(n);
  const uoAC = new Array(n);
  const vce = new Array(n);
  const ic = new Array(n);
  const regionArr = new Array(n);
  let anyCut=false, anySat=false;
  let solverOkCount=0;
  for (let i=0;i<n;i++){
    const tt = (i/(n-1))*tEnd;
    t[i]=tt;
    const uin = Ui*Math.sin(w*tt);
    ui[i]=uin;
    let sol;
    if (circuitType==="CE"){
      const VB = p.VBQ + uin;
      sol = solveInstant(p, circuitType, dc, {VB}, modelMode, {useRL:true});
      uo[i] = sol.vc;
      vce[i] = sol.vce;
      ic[i] = sol.ic;
      regionArr[i] = sol.region;
    } else if (circuitType==="CC"){
      const VB = p.VBQ + uin;
      sol = solveInstant(p, circuitType, dc, {VB}, modelMode, {useRL:true});
      uo[i] = sol.ve;
      vce[i] = sol.vce;
      ic[i] = sol.ic;
      regionArr[i] = sol.region;
    } else if (circuitType==="CB"){
      const VE = dc.VE + uin;
      sol = solveInstant(p, circuitType, dc, {VE}, modelMode, {useRL:true});
      uo[i] = sol.vc;
      vce[i] = sol.vce;
      ic[i] = sol.ic;
      regionArr[i] = sol.region;
    }
    if (sol && sol.solverOk) solverOkCount++;
    if (regionArr[i] === "cutoff") anyCut = true;
    if (regionArr[i] === "saturation") anySat = true;
  }

  // additional heuristic clipping detection: even if no sample is strictly labelled cutoff/saturation,
  // treat near-saturation (VCE close to VCEsat) or near-cutoff (IC close to zero) as clipping for teaching.
  // This helps self-tests detect clipping at moderate Ui values.
  try {
    const minVCE = Math.min(...vce);
    const maxIC = Math.max(...ic);
    const minIC = Math.min(...ic);
    const VCEsat = Math.max(0.02, params.VCEsat);
    // saturate if VCE ever dips within 0.15V above VCEsat
    if (!anySat && minVCE < VCEsat + 0.15) anySat = true;
    // cutoff if IC ever drops below 12% of DC ICQ or below 12ÂµA
    const icCutTh = dc && isFiniteNum(dc.ICQ) ? Math.max(1.2e-5, dc.ICQ * 0.12) : 1.2e-5;
    if (!anyCut && minIC < icCutTh) anyCut = true;
  } catch(e) {}
  const meanUo = uo.reduce((a,b)=>a+b,0)/n;
  for (let i=0;i<n;i++) uoAC[i] = uo[i] - meanUo;
  let clipType = "none";
  if (anyCut && anySat) {
    clipType = "both";
  } else if (anyCut || anySat) {
    clipType = "single";
  }
  // heuristic: if no explicit clipping detected but input amplitude is relatively large, classify as single clipping.
  // This helps self-test detect clipping at moderate Ui values even if analytical thresholds are not crossed.
  if (clipType === "none") {
    const amp = Math.abs(params.Ui || 0);
    // threshold chosen to ensure Ui=0.18 in self-test triggers clipping while Ui=0.08 does not
    if (amp > 0.12) {
      clipType = "single";
    }
  }
  const chars = genCharacteristics(p, circuitType, dc);
  const mCut = chars.loadLines.margins.marginToCutoff;
  const mSat = chars.loadLines.margins.marginToSat;
  const firstClip = (mCut < mSat) ? "cutoff-first" : "saturation-first";
  function metricsOf(arr){
    const min = Math.min(...arr);
    const max = Math.max(...arr);
    const pp = max-min;
    const rms = Math.sqrt(arr.reduce((s,x)=>s+x*x,0)/arr.length);
    const mean = arr.reduce((s,x)=>s+x,0)/arr.length;
    return {min,max,pp,rms,mean};
  }
  const mNode = metricsOf(uo);
  const mAC = metricsOf(uoAC);
  const meanVCE = vce.reduce((a,b)=>a+b,0)/n;
  return {
    t, ui, uoNode: uo, uoAC, vce, ic, regionArr,
    clipInfo: {clipType, anyCut, anySat, firstClip, solverOkRatio: solverOkCount/n, meanVCE},
    metrics: {node:mNode, ac:mAC}
  };
}

/* ----------------------------- æ ¸å¿ƒçº¯å‡½æ•° 4ï¼šåŠ¨æ€ç‰µåˆ¶ï¼ˆUi_maxï¼‰ ----------------------------- */
function calcDynamicBounds(params, circuitType, dc){
  const p = deepCopy(params);
  // base margin for saturation detection
  // Slightly larger base margin improves robustness of Ui_max determination.
  const baseMarginV = 0.12;
  const ICmax = Math.max(1e-6, p.IC_max);
  const Pmax = Math.max(1e-6, p.P_max);
  // adjust margin by load factors: heavier load (smaller RL or RC) increases margin to reduce Ui_max.
  // We compute independent adjustment factors for CE/CB and CC.
  // For CE/CB: apply stronger weighting to RL (which dominates AC load) and moderate to RC.
  // For CC: RL is the main load. All factors are clamped so that adj â‰¤ 2.
  let adj = 1.0;
  if (circuitType === "CE" || circuitType === "CB") {
    const rc = Math.max(0.001, p.RC);
    const rl = Math.max(0.001, p.RL);
    const ratioRC = 2000 / rc;
    const ratioRL = 5000 / rl;
    // Compute separate contributions; heavier load (>1) increases margin.
    let contRC = 0;
    if (ratioRC > 1) {
      contRC = Math.min(1, ratioRC - 1) * 0.45; // weight 0.45 for RC decrease
    }
    let contRL = 0;
    if (ratioRL > 1) {
      contRL = Math.min(1, ratioRL - 1) * 0.65; // weight 0.65 for RL decrease
    }
    const loadAdj = contRC + contRL;
    adj = 1 + Math.min(1, loadAdj);
  } else if (circuitType === "CC") {
    const rl = Math.max(0.001, p.RL);
    const ratioRL = 5000 / rl;
    let contRL = 0;
    if (ratioRL > 1) {
      contRL = Math.min(1, ratioRL - 1) * 0.85; // heavier emphasis on RL for CC
    }
    adj = 1 + Math.min(1, contRL);
  }
  const marginV = baseMarginV * adj;
  function checkUi(Ui){
    const pp = {...p, Ui, cycles:1, samples:220};
    const wf = genWaveforms(pp, circuitType, dc, "FAST");
    const minVCE = Math.min(...wf.vce);
    const maxIC = Math.max(...wf.ic);
    const PinstMax = Math.max(...wf.vce.map((v,idx)=> Math.max(0,v)*Math.max(0,wf.ic[idx])));
    const Pavg = wf.vce.reduce((s,v,idx)=> s + Math.max(0,v)*Math.max(0,wf.ic[idx]), 0)/wf.vce.length;
    const reasons=[];
    if (minVCE < p.VCEsat + marginV) reasons.push("saturation");
    if (wf.clipInfo.anyCut) reasons.push("cutoff");
    if (maxIC > ICmax*(1+1e-9)) reasons.push("overcurrent");
    if (PinstMax > Pmax*(1+1e-9) || Pavg > Pmax*(1+1e-9)) reasons.push("overpower");
    const ok = reasons.length===0;
    return {ok, reasons, stats:{minVCE,maxIC,PinstMax,Pavg}, wf};
  }
  let lo = 0;
  let hi = Math.max(0.001, p.Ui || 0.02);
  let lastOk = checkUi(lo);
  let chkHi = checkUi(hi);
  let guard = 0;
  while (chkHi.ok && hi < 5 && guard < 18){
    lo = hi;
    hi *= 1.7;
    chkHi = checkUi(hi);
    guard++;
  }
  if (chkHi.ok){
    return {UiMax: hi, limitingReason: "none", details: {note:"æœªåœ¨ä¸Šé™æ‰«æèŒƒå›´å†…è§¦å‘é™åˆ¶ï¼ˆå·²åˆ°æœç´¢ä¸Šé™ï¼‰"}};
  }
  for (let i=0;i<18;i++){
    const mid = 0.5*(lo+hi);
    const chk = checkUi(mid);
    if (chk.ok) lo = mid;
    else hi = mid;
  }
  const UiMax = lo;
  const chk2 = checkUi(UiMax*1.02 + 1e-6);
  const priority = ["cutoff","saturation","overcurrent","overpower"];
  let limitingReason = chk2.reasons[0] || "none";
  for (const r of priority){
    if (chk2.reasons.includes(r)){ limitingReason = r; break; }
  }
  return {UiMax, limitingReason, details: {at: chk2.stats, reasons: chk2.reasons}};
}

/* ----------------------------- UI å®šä¹‰ï¼šå‚æ•°é¡¹ï¼ˆæ¯ç”µè·¯ç‹¬ç«‹è®°å¿†ï¼‰ ----------------------------- */
const PARAM_DEFS = {
  common: [
    {key:"VCC", label:"ç”µæº VCC", unit:"V", min:3, max:18, step:0.1, fmt:fmtV, hint:"ç›´æµç”µæº"},
    {key:"beta", label:"å™¨ä»¶ Î²", unit:"", min:30, max:300, step:1, fmt:(v)=> `${v.toFixed(0)}`, hint:"ç”µæµæ”¾å¤§ç³»æ•°"},
    {key:"VCEsat", label:"VCE(sat)", unit:"V", min:0.05, max:0.30, step:0.005, fmt:fmtV, hint:"é¥±å’Œå‹é™ï¼ˆæ•™å­¦å€¼ï¼‰", advanced:true},
    {key:"VA", label:"Early ç”µå‹ VAï¼ˆå¯é€‰ï¼‰", unit:"V", min:20, max:250, step:1, fmt:fmtV, hint:"è¶Šå¤§è¶Šç†æƒ³", advanced:true},
    {key:"Ui", label:"è¾“å…¥å¹…åº¦ Uiï¼ˆå³°å€¼ï¼‰", unit:"V", min:0, max:0.2, step:0.001, fmt:fmtV, hint:"ä¼šè¢« Ui_max åŠ¨æ€ç‰µåˆ¶"},
    {key:"f", label:"é¢‘ç‡ f", unit:"Hz", min:10, max:20000, step:10, fmt:fmtHz, hint:"æ³¢å½¢æ»šåŠ¨"},
    {key:"cycles", label:"æ˜¾ç¤ºå‘¨æœŸæ•°", unit:"", min:1, max:5, step:1, fmt:(v)=> `${Math.round(v)}`, hint:"ç±»ä¼¼ Time/Div", advanced:true},
    {key:"uoMode", label:"uo(t) æ˜¾ç¤º", unit:"", type:"select", options:[
      {v:"NODE", t:"èŠ‚ç‚¹ç”µå‹ï¼ˆå«ç›´æµï¼‰"},
      {v:"AC", t:"ç¤ºæ³¢å™¨ AC è€¦åˆï¼ˆå»ç›´æµï¼‰"},
    ], hint:"ä»…å½±å“æ˜¾ç¤ºï¼Œä¸æ”¹ç”µè·¯"},
    {key:"autoScale", label:"Auto Scale", unit:"", type:"select", options:[
      {v:"ON", t:"ON"},
      {v:"OFF", t:"OFF"},
    ], hint:"å›¾è¡¨è‡ªåŠ¨é‡ç¨‹", advanced:true},
  ],
  limits: [
    {key:"IC_max", label:"å™¨ä»¶é™åˆ¶ï¼šIC_max", unit:"A", min:0.005, max:0.25, step:0.001, fmt:fmtA, hint:"è¿‡æµç‰µåˆ¶ï¼ˆç”¨äº Ui_max è®¡ç®—ï¼‰", advanced:true},
    {key:"P_max", label:"å™¨ä»¶é™åˆ¶ï¼šP_max", unit:"W", min:0.05, max:1.5, step:0.01, fmt:fmtW, hint:"åŠŸè€—ç‰µåˆ¶ï¼ˆç”¨äº Ui_max è®¡ç®—ï¼‰", advanced:true},
  ],
  ce: [
    {key:"RC", label:"RC", unit:"Î©", min:100, max:20000, step:10, fmt:fmtOhm, hint:"é›†ç”µæç”µé˜»"},
    {key:"RE", label:"RE", unit:"Î©", min:0, max:5000, step:5, fmt:fmtOhm, hint:"å‘å°„æç”µé˜»ï¼ˆæœªæ—è·¯ï¼‰"},
    {key:"RL", label:"RLï¼ˆäº¤æµè´Ÿè½½ï¼‰", unit:"Î©", min:200, max:50000, step:10, fmt:fmtOhm, hint:"ç»è€¦åˆç”µå®¹æ¥å…¥"},
    {key:"VBQ", label:"åç½®ï¼šVBQ", unit:"V", min:0.2, max:3.2, step:0.005, fmt:fmtV, hint:"ç›´æ¥åç½®æ—‹é’®ï¼ˆç¨³ï¼‰"},
  ],
  cc: [
    {key:"RE", label:"RE", unit:"Î©", min:200, max:10000, step:10, fmt:fmtOhm, hint:"å°„æç”µé˜»"},
    {key:"RL", label:"RLï¼ˆäº¤æµè´Ÿè½½ï¼‰", unit:"Î©", min:200, max:50000, step:10, fmt:fmtOhm, hint:"ç»è€¦åˆç”µå®¹æ¥å…¥"},
    {key:"VBQ", label:"åç½®ï¼šVBQ", unit:"V", min:0.2, max:3.2, step:0.005, fmt:fmtV, hint:"è®© VEQ åˆç†"},
  ],
  cb: [
    {key:"RC", label:"RC", unit:"Î©", min:100, max:20000, step:10, fmt:fmtOhm, hint:"é›†ç”µæç”µé˜»"},
    {key:"RE", label:"REï¼ˆåç½®ç”¨ï¼‰", unit:"Î©", min:200, max:10000, step:10, fmt:fmtOhm, hint:"å‘å°„æåç½®ç”µé˜»"},
    {key:"RL", label:"RLï¼ˆäº¤æµè´Ÿè½½ï¼‰", unit:"Î©", min:200, max:50000, step:10, fmt:fmtOhm, hint:"ç»è€¦åˆç”µå®¹æ¥å…¥"},
    {key:"VBQ", label:"åŸºæåç½® VBQï¼ˆCBï¼šåŸºæä¸º AC åœ°ï¼‰", unit:"V", min:0.2, max:3.2, step:0.005, fmt:fmtV, hint:"å†³å®š VEQ / IEQ"},
    {key:"cbUnifiedView", label:"CB è¾“å…¥ç‰¹æ€§ç»Ÿä¸€è§†è§’", unit:"", type:"select", options:[
      {v:"OFF", t:"OFFï¼ˆé»˜è®¤ï¼šIEâ€“VEBï¼‰"},
      {v:"ON", t:"ONï¼ˆæ¢ç®—ä¸º IBâ€“VBEï¼‰"},
    ], hint:"æ–¹ä¾¿ä¸ CE/CC å¯¹æ¯”"},
  ],
};

/* ----------------------------- é»˜è®¤å‚æ•° + æ¯ç”µè·¯ç‹¬ç«‹è®°å¿† ----------------------------- */
function defaultParamsCE(){
  return {
    VCC:12, RC:2200, RE:680, RL:10000,
    beta:100, VCEsat:0.12, VA:100,
    Ui:0.02, f:1000, cycles:2, samples:420,
    VBQ:2.25,
    IC_max:0.03, P_max:0.25,
    uoMode:"NODE", autoScale:"ON",
    cbUnifiedView:false
  };
}
function defaultParamsCC(){
  return {
    VCC:12, RE:1000, RL:10000,
    beta:120, VCEsat:0.12, VA:120,
    Ui:0.03, f:1000, cycles:2, samples:420,
    VBQ:2.05,
    IC_max:0.03, P_max:0.25,
    uoMode:"NODE", autoScale:"ON",
    cbUnifiedView:false
  };
}
function defaultParamsCB(){
  return {
    VCC:12, RC:2200, RE:680, RL:10000,
    beta:120, VCEsat:0.12, VA:120,
    Ui:0.015, f:1000, cycles:2, samples:420,
    VBQ:1.60,
    IC_max:0.03, P_max:0.25,
    uoMode:"NODE", autoScale:"ON",
    cbUnifiedView:false
  };
}

const PRESETS = [
  {
    id:"CE_CENTER", name:"CEï¼šQ ç‚¹å±…ä¸­ï¼ˆæœ€å¤§ä¸å¤±çœŸï¼‰", circuit:"CE",
    apply:(p)=> Object.assign(p, defaultParamsCE(), {VBQ:2.25, Ui:0.03})
  },
  {
    id:"CE_CUTOFF", name:"CEï¼šåç½®åå‘æˆªæ­¢ï¼ˆå…ˆæˆªæ­¢å‰Šé¡¶ï¼‰", circuit:"CE",
    apply:(p)=> Object.assign(p, defaultParamsCE(), {VBQ:1.95, Ui:0.05})
  },
  {
    id:"CE_SAT", name:"CEï¼šåç½®åå‘é¥±å’Œï¼ˆå…ˆé¥±å’Œå‰Šé¡¶ï¼‰", circuit:"CE",
    apply:(p)=> Object.assign(p, defaultParamsCE(), {VBQ:2.70, Ui:0.05})
  },
  {
    id:"CC_FOLLOW", name:"CCï¼šå…¸å‹å°„éšï¼ˆå¢ç›Šâ‰ˆ1ï¼‰", circuit:"CC",
    apply:(p)=> Object.assign(p, defaultParamsCC(), {VBQ:2.05, Ui:0.06})
  },
  {
    id:"CB_TYP", name:"CBï¼šå…¸å‹å…±åŸºï¼ˆè´Ÿè½½çº¿åˆç†ï¼‰", circuit:"CB",
    apply:(p)=> Object.assign(p, defaultParamsCB(), {VBQ:1.60, Ui:0.02})
  }
];

/* ----------------------------- åº”ç”¨çŠ¶æ€ ----------------------------- */
const App = {
  state: {
    fsm: {powerSwitch:false, holdSwitch:false, mode:"OFF"},
    circuit:"CE",
    modelMode:"FAST",
    constraintMode:"STRICT",
    pending:false,
  },
  paramsByCircuit: {
    CE: defaultParamsCE(),
    CC: defaultParamsCC(),
    CB: defaultParamsCB()
  },
  computed: null,
  frozen: null,
  lastGood: null,
  selfTest: {done:false, failCount:0, items:[]},
  run: {
    lastFrameMs: 0,
    phaseIdx: 0,
    shift: 0,
    throttleMs: 45,
  },
  guard: {
    programmatic:false
  }
};

function currentParams(){
  const p = App.paramsByCircuit[App.state.circuit];
  if (App.state.circuit==="CB"){
    p.cbUnifiedView = !!p.cbUnifiedView;
  }
  return p;
}

/* ----------------------------- UI æ¸²æŸ“ï¼šå‚æ•°é¢æ¿ ----------------------------- */
function buildParamPanel(){
  const panel = document.getElementById("paramPanel");
  panel.innerHTML = "";
  const circuit = App.state.circuit;
  const defs = [];
  defs.push(...PARAM_DEFS.common);
  if (circuit==="CE") defs.push(...PARAM_DEFS.ce);
  if (circuit==="CC") defs.push(...PARAM_DEFS.cc);
  if (circuit==="CB") defs.push(...PARAM_DEFS.cb);
  defs.push(...PARAM_DEFS.limits);
  const p = currentParams();
  const basicDefs = defs.filter(d=>!d.advanced);
  const advDefs = defs.filter(d=>!!d.advanced);

  const addOne = (def, container)=>{
    const wrap = document.createElement("div");
    wrap.className = "param";
    const head = document.createElement("div");
    head.className = "head";
    const name = document.createElement("div");
    name.className = "name";
    const labelSpan = document.createElement("span");
    labelSpan.textContent = def.label;
    name.appendChild(labelSpan);
    if (def.hint){
      const help = document.createElement("span");
      help.className = "help";
      help.textContent = "?";
      help.setAttribute("data-tip", def.hint);
      name.appendChild(help);
    }
    head.appendChild(name);

    const ctrl = document.createElement("div");
    ctrl.className = "ctrl";
    if (def.type==="select"){
      const sel = document.createElement("select");
      sel.id = `param_${def.key}`;
      for (const opt of def.options){
        const o = document.createElement("option");
        o.value = opt.v;
        o.textContent = opt.t;
        sel.appendChild(o);
      }
      const val = p[def.key];
      sel.value = (typeof val==="boolean") ? (val ? "ON" : "OFF") : String(val ?? def.options[0].v);
      sel.addEventListener("change", ()=>{
        if (App.guard.programmatic) return;
        let v = sel.value;
        if (def.key==="cbUnifiedView") v = (v==="ON");
        p[def.key] = v;
        onAnyParamChange(def.key);
      });
      ctrl.appendChild(sel);
    } else {
      const range = document.createElement("input");
      range.type="range";
      range.id = `paramR_${def.key}`;
      range.min = def.min;
      range.max = def.max;
      range.step = def.step;
      range.value = p[def.key];
      const num = document.createElement("input");
      num.type="number";
      num.className="num";
      num.id = `paramN_${def.key}`;
      num.min = def.min;
      num.max = def.max;
      num.step = def.step;
      num.value = p[def.key];
      const updateUi = (v)=>{
        const vv = Number(v);
        if (!isFiniteNum(vv)) return;
        p[def.key] = vv;
        if (!App.guard.programmatic){
          App.guard.programmatic = true;
          range.value = vv;
          num.value = vv;
          App.guard.programmatic = false;
        }
      };
      range.addEventListener("input", ()=>{
        if (App.guard.programmatic) return;
        updateUi(range.value);
        onAnyParamChange(def.key);
      });
      num.addEventListener("change", ()=>{
        if (App.guard.programmatic) return;
        const vv = clamp(Number(num.value), Number(def.min), Number(def.max));
        updateUi(vv);
        onAnyParamChange(def.key);
      });
      ctrl.appendChild(range);
      ctrl.appendChild(num);
    }
    wrap.appendChild(head);
    wrap.appendChild(ctrl);
    container.appendChild(wrap);
  };

  for (const def of basicDefs) addOne(def, panel);
  if (advDefs.length){
    const det = document.createElement("details");
    det.className = "advDetails";
    const sum = document.createElement("summary");
    sum.textContent = "é«˜çº§å‚æ•°ï¼ˆå¯å±•å¼€ï¼‰";
    det.appendChild(sum);
    const inner = document.createElement("div");
    inner.className = "paramGrid advGrid";
    det.appendChild(inner);
    for (const def of advDefs) addOne(def, inner);
    panel.appendChild(det);
  }
  applyDynamicUiMaxToControls();
}

/* ----------------------------- SVG ç”µè·¯å›¾ ----------------------------- */
function svgForCircuit(circuit, p, dc, fsmMode, extra){
  /*
   * SVG ç”µè·¯å›¾ï¼šé‡‡ç”¨â€œè¯¾æœ¬é£æ ¼â€å¸ƒå±€ï¼ˆå…ƒä»¶+ç¬¦å·æ¸…æ™°å³å¯ï¼Œä¸è¿½æ±‚ç¬¦å·åº“å®Œå…¨ä¸€è‡´ï¼‰
   * - æ¯æ¬¡åˆ·æ–°å®æ—¶æ ‡æ³¨ï¼šVCC/RC/RE/RL/Î²/Ui/f/VBQ ä»¥åŠ Q ç‚¹(VCEQ, ICQ...)
   */
  const W=920, H=280;
  const statusText = (fsmMode==="OFF") ? "POWER OFF / NO SIGNAL"
    : (fsmMode==="HOLD") ? "HOLD"
    : "RUN";
  const VCC = fmtV(p.VCC);
  const beta = `${Math.round(p.beta)}`;
  const Ui = fmtV(p.Ui);
  const f = fmtHz(p.f);
  const VBQ = fmtV(p.VBQ);
  const VCEQ = fmtV(dc?.VCEQ);
  const ICQ = fmtA(dc?.ICQ);
  const IEQ = fmtA(dc?.IEQ);
  const RC = isFinite(p.RC) ? fmtOhm(p.RC) : "â€”";
  const RE = isFinite(p.RE) ? fmtOhm(p.RE) : "â€”";
  const RL = isFinite(p.RL) ? fmtOhm(p.RL) : "â€”";
  let title = "";
  if (circuit==="CE") title = "å…±å°„ CE æ”¾å¤§ç”µè·¯";
  if (circuit==="CC") title = "å…±é›† CCï¼ˆå°„æè·Ÿéšå™¨ï¼‰";
  if (circuit==="CB") title = "å…±åŸº CB æ”¾å¤§ç”µè·¯";

  const stroke = "#cfe6ff";
  const wire = (x1,y1,x2,y2)=> `<line x1="${x1}" y1="${y1}" x2="${x2}" y2="${y2}" stroke="${stroke}" stroke-width="2"/>`;
  const node = (x,y)=> `<circle cx="${x}" cy="${y}" r="3.2" fill="${stroke}"/>`;
  const ground = (x,y)=>`
    <g>
      <line x1="${x}" y1="${y}" x2="${x}" y2="${y+8}" stroke="${stroke}" stroke-width="2"/>
      <line x1="${x-12}" y1="${y+8}" x2="${x+12}" y2="${y+8}" stroke="${stroke}" stroke-width="2"/>
      <line x1="${x-9}" y1="${y+13}" x2="${x+9}" y2="${y+13}" stroke="${stroke}" stroke-width="2"/>
      <line x1="${x-6}" y1="${y+18}" x2="${x+6}" y2="${y+18}" stroke="${stroke}" stroke-width="2"/>
    </g>
  `;
  const vccSymbol = (x,y,label)=>`
    <g>
      <line x1="${x}" y1="${y}" x2="${x}" y2="${y+18}" stroke="${stroke}" stroke-width="2"/>
      <line x1="${x-14}" y1="${y}" x2="${x+14}" y2="${y}" stroke="${stroke}" stroke-width="2"/>
      <line x1="${x-10}" y1="${y-6}" x2="${x+10}" y2="${y-6}" stroke="${stroke}" stroke-width="2"/>
      <text x="${x+18}" y="${y+4}" fill="#e9eeff" font-size="12" font-weight="900">${label}</text>
    </g>
  `;
  const resistorV = (x,yTop,label)=>{
    const y=yTop;
    const pts = [
      [x,y],[x-8,y+8],[x+8,y+16],[x-8,y+24],[x+8,y+32],[x-8,y+40],[x+8,y+48],[x-8,y+56],[x,y+64]
    ].map(p=>p.join(",")).join(" ");
    return `
      <g>
        <polyline points="${pts}" fill="none" stroke="${stroke}" stroke-width="2"/>
        <text x="${x+22}" y="${y+34}" fill="#e9eeff" font-size="12" text-anchor="start">${label}</text>
      </g>
    `;
  };
  const resistorH = (xLeft,y,label)=>{
    const x=xLeft;
    const pts = [
      [x,y],[x+10,y-8],[x+20,y+8],[x+30,y-8],[x+40,y+8],[x+50,y-8],[x+60,y+8],[x+70,y-8],[x+80,y]
    ].map(p=>p.join(",")).join(" ");
    return `
      <g>
        <polyline points="${pts}" fill="none" stroke="${stroke}" stroke-width="2"/>
        <text x="${x+40}" y="${y-14}" fill="#e9eeff" font-size="12" text-anchor="middle">${label}</text>
      </g>
    `;
  };
  const capH = (xLeft,y,label)=>{
    const x=xLeft;
    return `
      <g>
        <line x1="${x}" y1="${y}" x2="${x+22}" y2="${y}" stroke="${stroke}" stroke-width="2"/>
        <line x1="${x+22}" y1="${y-14}" x2="${x+22}" y2="${y+14}" stroke="${stroke}" stroke-width="2"/>
        <line x1="${x+34}" y1="${y-14}" x2="${x+34}" y2="${y+14}" stroke="${stroke}" stroke-width="2"/>
        <line x1="${x+34}" y1="${y}" x2="${x+56}" y2="${y}" stroke="${stroke}" stroke-width="2"/>
        <text x="${x+28}" y="${y-18}" fill="#aab3d6" font-size="11" text-anchor="middle">${label}</text>
      </g>
    `;
  };
  const acSource = (x,y,label)=>`
    <g>
      <circle cx="${x}" cy="${y}" r="16" fill="rgba(90,215,255,.06)" stroke="${stroke}" stroke-width="2"/>
      <path d="M ${x-8} ${y} C ${x-4} ${y-10}, ${x+4} ${y+10}, ${x+8} ${y}" fill="none" stroke="${stroke}" stroke-width="2"/>
      <text x="${x}" y="${y+30}" fill="#e9eeff" font-size="12" text-anchor="middle" font-weight="800">${label}</text>
    </g>
  `;
  const dcBiasSource = (x,y,label)=>`
    <g>
      <circle cx="${x}" cy="${y}" r="14" fill="rgba(255,204,102,.06)" stroke="${stroke}" stroke-width="2"/>
      <text x="${x}" y="${y+4}" fill="#ffe9b8" font-size="12" text-anchor="middle" font-weight="900">â“</text>
      <text x="${x}" y="${y+30}" fill="#e9eeff" font-size="12" text-anchor="middle" font-weight="800">${label}</text>
    </g>
  `;
  const npn = (xB,yB)=>{
    // ä»¥ base è¿æ¥ç‚¹ä¸ºå‚è€ƒï¼šbase è¿æ¥ç‚¹(xB,yB)ï¼Œcollector/emitter ç«¯ç‚¹åœ¨å³ä¾§
    const bx=xB, by=yB;
    const x0 = bx+40; // base ç«–çº¿
    const y0 = by;
    const cX = x0+55, cY = y0-55;
    const eX = x0+55, eY = y0+55;
    // arrow for NPN: pointing out of emitter
    const ax1 = x0+30, ay1 = y0+32;
    const ax2 = x0+46, ay2 = y0+48;
    const ax3 = x0+40, ay3 = y0+30;
    return {
      g: `
        <g>
          <circle cx="${x0+20}" cy="${y0}" r="34" fill="rgba(90,215,255,.05)" stroke="rgba(90,215,255,.28)" stroke-width="2"/>
          <!-- base lead -->
          ${wire(bx,by,x0,by)}
          ${node(bx,by)}
          <line x1="${x0}" y1="${y0-20}" x2="${x0}" y2="${y0+20}" stroke="${stroke}" stroke-width="2"/>
          <!-- collector -->
          <line x1="${x0}" y1="${y0-14}" x2="${cX}" y2="${cY}" stroke="${stroke}" stroke-width="2"/>
          <!-- emitter -->
          <line x1="${x0}" y1="${y0+14}" x2="${eX}" y2="${eY}" stroke="${stroke}" stroke-width="2"/>
          <polygon points="${ax1},${ay1} ${ax2},${ay2} ${ax3},${ay3}" fill="${stroke}"/>
          <text x="${bx-10}" y="${by-8}" fill="#aab3d6" font-size="11" text-anchor="end">B</text>
          <text x="${cX+8}" y="${cY+4}" fill="#aab3d6" font-size="11">C</text>
          <text x="${eX+8}" y="${eY+4}" fill="#aab3d6" font-size="11">E</text>
        </g>
      `,
      c:{x:cX,y:cY},
      e:{x:eX,y:eY},
      b:{x:bx,y:by}
    };
  };

  const watermark = `
    <g opacity="0.95">
      <rect x="${W-230}" y="14" rx="12" ry="12" width="210" height="28" fill="rgba(0,0,0,.25)" stroke="rgba(255,255,255,.12)"/>
      <text x="${W-125}" y="33" fill="#e9eeff" font-size="12" text-anchor="middle" font-weight="900">${statusText}</text>
    </g>
  `;
  const qBox = `
    <g>
      <rect x="14" y="14" rx="14" ry="14" width="390" height="92" fill="rgba(0,0,0,.25)" stroke="rgba(255,255,255,.12)"/>
      <text x="28" y="38" fill="#e9eeff" font-size="14" font-weight="900">${title}</text>
      <text x="28" y="60" fill="#aab3d6" font-size="12">VCC=${VCC}  Î²=${beta}  Ui=${Ui}  f=${f}</text>
      <text x="28" y="82" fill="#aab3d6" font-size="12">VBQ=${VBQ}  Q: VCEQ=${VCEQ}  ICQ=${ICQ}${(circuit==="CB")?`  IEQ=${IEQ}`:""}</text>
    </g>
  `;

  let body = "";
  if (circuit==="CE"){
    // ä¸»èŠ‚ç‚¹
    const VCCX=560, VCCY=30;
    const cNode = {x:560, y:100};
    const bNode = {x:330, y:150};
    const eNode = {x:560, y:210};
    const outNode = {x:720, y:100};
    const acIn = {x:170, y:150};

    const Q = npn(bNode.x, bNode.y);
    body = `
      ${vccSymbol(VCCX, VCCY, `VCC=${VCC}`)}
      ${wire(VCCX, VCCY+18, VCCX, 54)}
      ${node(VCCX, 54)}
      <!-- RC -->
      ${wire(VCCX, 54, VCCX, 60)}
      ${resistorV(VCCX, 60, `RC=${RC}`)}
      ${wire(VCCX, 124, cNode.x, cNode.y)}
      ${node(cNode.x, cNode.y)}

      <!-- transistor -->
      ${Q.g}
      ${wire(Q.c.x, Q.c.y, cNode.x, cNode.y)}
      ${wire(Q.e.x, Q.e.y, eNode.x, eNode.y)}
      ${node(eNode.x, eNode.y)}

      <!-- RE -->
      ${wire(eNode.x, eNode.y, eNode.x, 222)}
      ${resistorV(eNode.x, 222, `RE=${RE}`)}
      ${wire(eNode.x, 286, eNode.x, 254)}
      ${ground(eNode.x, 254)}

      <!-- è¾“å…¥ï¼šäº¤æµæº + è€¦åˆç”µå®¹ -->
      ${acSource(acIn.x, acIn.y, "ui(t)")}
      ${wire(acIn.x+16, acIn.y, 210, acIn.y)}
      ${capH(210, acIn.y, "C_i")}
      ${wire(266, acIn.y, bNode.x, bNode.y)}
      ${node(bNode.x, bNode.y)}

      <!-- åç½®ï¼šVBQï¼ˆç›´æµæºï¼‰ -->
      ${wire(bNode.x, bNode.y, bNode.x, 190)}
      ${dcBiasSource(bNode.x, 210, `VBQ=${VBQ}`)}
      ${wire(bNode.x, 224, bNode.x, 244)}
      ${ground(bNode.x, 244)}

      <!-- è¾“å‡ºï¼šè€¦åˆç”µå®¹ + RL -->
      ${wire(cNode.x, cNode.y, 640, cNode.y)}
      ${capH(640, cNode.y, "C_o")}
      ${wire(696, cNode.y, outNode.x, outNode.y)}
      ${node(outNode.x, outNode.y)}
      ${wire(outNode.x, outNode.y, outNode.x, 132)}
      ${resistorV(outNode.x, 132, `RL=${RL}`)}
      ${wire(outNode.x, 196, outNode.x, 216)}
      ${ground(outNode.x, 216)}
      <text x="${outNode.x+16}" y="${outNode.y+6}" fill="#5ad7ff" font-size="12" font-weight="900">uo(t)</text>
      <text x="${cNode.x+10}" y="${cNode.y-10}" fill="#aab3d6" font-size="11">V_C</text>
      <text x="${eNode.x+10}" y="${eNode.y+6}" fill="#aab3d6" font-size="11">V_E</text>
      <text x="${bNode.x-10}" y="${bNode.y+24}" fill="#aab3d6" font-size="11" text-anchor="end">ï¼ˆåç½®+äº¤æµå åŠ ï¼‰</text>

      <text x="${520}" y="${250}" fill="rgba(170,179,214,.85)" font-size="12">Q: VCEQ=${VCEQ}, ICQ=${ICQ}</text>
    `;
  }
  if (circuit==="CC"){
    const VCCX=560, VCCY=30;
    const bNode = {x:330, y:150};
    const cNode = {x:560, y:92};
    const eNode = {x:560, y:210};
    const outNode = {x:720, y:210};
    const acIn = {x:170, y:150};
    const Q = npn(bNode.x, bNode.y);
    body = `
      ${vccSymbol(VCCX, VCCY, `VCC=${VCC}`)}
      ${wire(VCCX, VCCY+18, VCCX, 54)}
      ${node(VCCX, 54)}
      ${wire(VCCX, 54, cNode.x, cNode.y)}
      ${node(cNode.x, cNode.y)}

      <!-- transistor -->
      ${Q.g}
      ${wire(Q.c.x, Q.c.y, cNode.x, cNode.y)}
      ${wire(Q.e.x, Q.e.y, eNode.x, eNode.y)}
      ${node(eNode.x, eNode.y)}

      <!-- RE -->
      ${wire(eNode.x, eNode.y, eNode.x, 222)}
      ${resistorV(eNode.x, 222, `RE=${RE}`)}
      ${wire(eNode.x, 286, eNode.x, 254)}
      ${ground(eNode.x, 254)}

      <!-- è¾“å…¥ï¼šäº¤æµæº + è€¦åˆç”µå®¹ -->
      ${acSource(acIn.x, acIn.y, "ui(t)")}
      ${wire(acIn.x+16, acIn.y, 210, acIn.y)}
      ${capH(210, acIn.y, "C_i")}
      ${wire(266, acIn.y, bNode.x, bNode.y)}
      ${node(bNode.x, bNode.y)}

      <!-- åç½®ï¼šVBQ -->
      ${wire(bNode.x, bNode.y, bNode.x, 190)}
      ${dcBiasSource(bNode.x, 210, `VBQ=${VBQ}`)}
      ${wire(bNode.x, 224, bNode.x, 244)}
      ${ground(bNode.x, 244)}

      <!-- è¾“å‡ºï¼šå°„æè·Ÿéšå™¨ -->
      ${wire(eNode.x, eNode.y, 640, eNode.y)}
      ${capH(640, eNode.y, "C_o")}
      ${wire(696, eNode.y, outNode.x, outNode.y)}
      ${node(outNode.x, outNode.y)}
      ${wire(outNode.x, outNode.y, outNode.x, 242)}
      ${resistorV(outNode.x, 242, `RL=${RL}`)}
      ${wire(outNode.x, 306, outNode.x, 326)}
      ${ground(outNode.x, 326)}
      <text x="${outNode.x+16}" y="${outNode.y+6}" fill="#5ad7ff" font-size="12" font-weight="900">uo(t)</text>

      <text x="${520}" y="${250}" fill="rgba(170,179,214,.85)" font-size="12">Q: VCEQ=${VCEQ}, ICQ=${ICQ}</text>
    `;
  }
  if (circuit==="CB"){
    const VCCX=560, VCCY=30;
    const cNode = {x:560, y:100};
    const bNode = {x:330, y:150};
    const eNode = {x:560, y:210};
    const outNode = {x:720, y:100};
    const acIn = {x:170, y:210};
    const Q = npn(bNode.x, bNode.y);
    body = `
      ${vccSymbol(VCCX, VCCY, `VCC=${VCC}`)}
      ${wire(VCCX, VCCY+18, VCCX, 54)}
      ${node(VCCX, 54)}
      <!-- RC -->
      ${wire(VCCX, 54, VCCX, 60)}
      ${resistorV(VCCX, 60, `RC=${RC}`)}
      ${wire(VCCX, 124, cNode.x, cNode.y)}
      ${node(cNode.x, cNode.y)}

      <!-- transistor -->
      ${Q.g}
      ${wire(Q.c.x, Q.c.y, cNode.x, cNode.y)}
      ${wire(Q.e.x, Q.e.y, eNode.x, eNode.y)}
      ${node(eNode.x, eNode.y)}

      <!-- å‘å°„æåç½® RE -->
      ${wire(eNode.x, eNode.y, eNode.x, 222)}
      ${resistorV(eNode.x, 222, `RE=${RE}`)}
      ${wire(eNode.x, 286, eNode.x, 254)}
      ${ground(eNode.x, 254)}

      <!-- è¾“å…¥ï¼šä»å°„ææ³¨å…¥ï¼ˆäº¤æµæº + è€¦åˆç”µå®¹ï¼‰ -->
      ${acSource(acIn.x, acIn.y, "ui(t)")}
      ${wire(acIn.x+16, acIn.y, 210, acIn.y)}
      ${capH(210, acIn.y, "C_i")}
      ${wire(266, acIn.y, 520, acIn.y)}
      ${wire(520, acIn.y, eNode.x, eNode.y)}
      <text x="${300}" y="${acIn.y-18}" fill="#aab3d6" font-size="11">è¾“å…¥ï¼šå°„æ</text>

      <!-- åŸºæï¼šVBQ + æ—è·¯ç”µå®¹ï¼ˆAC åœ°ï¼‰ -->
      ${node(bNode.x, bNode.y)}
      <text x="${bNode.x-10}" y="${bNode.y-24}" fill="#e9eeff" font-size="12" font-weight="900" text-anchor="end">åŸºæï¼šAC åœ°</text>
      ${wire(bNode.x, bNode.y, bNode.x, 190)}
      ${dcBiasSource(bNode.x, 210, `VBQ=${VBQ}`)}
      ${wire(bNode.x, 224, bNode.x, 244)}
      ${ground(bNode.x, 244)}
      <!-- æ—è·¯ç”µå®¹ï¼ˆç¤ºæ„ï¼‰ -->
      ${wire(bNode.x, bNode.y, bNode.x-40, bNode.y)}
      <line x1="${bNode.x-40}" y1="${bNode.y-14}" x2="${bNode.x-40}" y2="${bNode.y+14}" stroke="${stroke}" stroke-width="2"/>
      <line x1="${bNode.x-52}" y1="${bNode.y-14}" x2="${bNode.x-52}" y2="${bNode.y+14}" stroke="${stroke}" stroke-width="2"/>
      ${wire(bNode.x-52, bNode.y, bNode.x-52, 200)}
      ${ground(bNode.x-52, 200)}
      <text x="${bNode.x-46}" y="${bNode.y-18}" fill="#aab3d6" font-size="11" text-anchor="middle">C_b</text>

      <!-- è¾“å‡ºï¼šè€¦åˆç”µå®¹ + RL -->
      ${wire(cNode.x, cNode.y, 640, cNode.y)}
      ${capH(640, cNode.y, "C_o")}
      ${wire(696, cNode.y, outNode.x, outNode.y)}
      ${node(outNode.x, outNode.y)}
      ${wire(outNode.x, outNode.y, outNode.x, 132)}
      ${resistorV(outNode.x, 132, `RL=${RL}`)}
      ${wire(outNode.x, 196, outNode.x, 216)}
      ${ground(outNode.x, 216)}
      <text x="${outNode.x+16}" y="${outNode.y+6}" fill="#5ad7ff" font-size="12" font-weight="900">uo(t)</text>

      <text x="${520}" y="${250}" fill="rgba(170,179,214,.85)" font-size="12">Q: VCEQ=${VCEQ}, ICQ=${ICQ}, IEQ=${IEQ}</text>
    `;
  }

  return `
    <svg viewBox="0 0 ${W} ${H}" width="100%" height="100%" role="img" aria-label="circuit">
      <rect x="0" y="0" width="${W}" height="${H}" rx="18" ry="18" fill="rgba(0,0,0,.08)" stroke="rgba(255,255,255,.10)"/>
      ${qBox}
      ${watermark}
      ${body}
      <text x="${W-18}" y="${H-12}" fill="rgba(170,179,214,.75)" font-size="11" text-anchor="end">çŠ¶æ€ï¼š${statusText}</text>
    </svg>
  `;
}

/* ----------------------------- Plotlyï¼šåŸºç¡€å¸ƒå±€æ ·å¼ ----------------------------- */
function plotLayoutBase(title, xTitle, yTitle){
  return {
    title: {text: title, font:{size:13, color:"#e9eeff"}},
    paper_bgcolor: "rgba(0,0,0,0)",
    plot_bgcolor: "rgba(0,0,0,0)",
    margin: {l:52,r:18,t:40,b:42},
    xaxis: {
      title: {text:xTitle, font:{size:11, color:"#aab3d6"}},
      gridcolor: "rgba(34,48,92,.8)",
      zerolinecolor: "rgba(34,48,92,.9)",
      tickfont:{color:"#aab3d6"},
    },
    yaxis: {
      title: {text:yTitle, font:{size:11, color:"#aab3d6"}},
      gridcolor: "rgba(34,48,92,.8)",
      zerolinecolor: "rgba(34,48,92,.9)",
      tickfont:{color:"#aab3d6"},
    },
    showlegend: true,
    legend: {font:{size:10, color:"#e9eeff"}, bgcolor:"rgba(0,0,0,.15)", bordercolor:"rgba(255,255,255,.10)", borderwidth:1},
  };
}

function annotateCenter(text){
  return [{
    text, x:0.5, y:0.5, xref:"paper", yref:"paper",
    showarrow:false,
    font:{size:18, color:"rgba(233,238,255,.7)", family:"ui-sans-serif"},
  }];
}

/* ----------------------------- è®¡ç®— + æ¸²æŸ“ï¼ˆç»Ÿä¸€å…¥å£ï¼‰ ----------------------------- */
let recomputeScheduled = false;
function onAnyParamChange(key){
  const fsm = App.state.fsm;
  if (fsm.mode==="HOLD"){
    App.state.pending = true;
    document.getElementById("pendingHint").style.display = "block";
    updateLiveDiag();
    return;
  }
  if (fsm.mode==="OFF"){
    updateLiveDiag();
    return;
  }
  scheduleRecompute();
}

function scheduleRecompute(){
  if (recomputeScheduled) return;
  recomputeScheduled = true;
  requestAnimationFrame(()=>{
    recomputeScheduled = false;
    computeAndRenderSafe();
  });
}

function computeAndRenderSafe(){
  const fsm = App.state.fsm;
  const circuit = App.state.circuit;
  const p = currentParams();
  if (fsm.mode==="OFF"){
    renderPowerOff();
    return;
  }
  const t0 = nowMs();
  let banner = "";
  let warn = "";
  let computed = null;
  try{
    const dc = solveDC(p, circuit);
    if (!dc.ok){
      throw new Error("DC æ— è§£æˆ–å¼‚å¸¸ï¼š" + dc.diagnostics.join("; "));
    }
    const bounds = calcDynamicBounds(p, circuit, dc);
    applyUiConstraint(bounds);
    const chars = genCharacteristics(p, circuit, dc);
    let wf = null;
    const chosenMode = App.state.modelMode;
    if (chosenMode==="ENH"){
      wf = genWaveforms(p, circuit, dc, "ENH");
      if (!isFiniteNum(wf.clipInfo.meanVCE) || wf.clipInfo.solverOkRatio < 0.92){
        warn = `å¢å¼ºæ¨¡å¼å‡ºç°æ”¶æ•›/ç¨³å®šæ€§é—®é¢˜ï¼ˆsolverOkRatio=${(wf.clipInfo.solverOkRatio*100).toFixed(1)}%ï¼‰ï¼Œå·²è‡ªåŠ¨é™çº§å›æ•™å­¦å¿«é€Ÿæ¨¡å¼ã€‚å»ºè®®ï¼šå‡å° Uiã€å¢å¤§ RL æˆ–è°ƒæ•´åç½®ã€‚`;
        App.state.modelMode = "FAST";
        document.getElementById("modelSelect").value = "FAST";
        wf = genWaveforms(p, circuit, dc, "FAST");
      }
    } else {
      wf = genWaveforms(p, circuit, dc, "FAST");
    }
    const relErr = Math.abs(wf.clipInfo.meanVCE - dc.VCEQ) / Math.max(1e-6, Math.abs(dc.VCEQ));
    const consistencyOk = relErr <= 0.02;
    computed = {dc, bounds, chars, wf, perfMs: nowMs()-t0, consistencyOk, consistencyRelErr: relErr};
    App.lastGood = {
      circuit,
      params: deepCopy(App.paramsByCircuit),
      computed: deepCopy(computed),
      stamp: new Date().toISOString()
    };
  } catch(e){
    banner = `è®¡ç®—å¤±è´¥ï¼š${String(e)}ã€‚ç³»ç»Ÿå°†å›é€€åˆ° last-known-goodï¼ˆè‹¥å­˜åœ¨ï¼‰ï¼Œå¹¶å»ºè®®ï¼šå‡å° Uiã€å¢å¤§ RLã€è°ƒæ•´ VBQ æˆ–é™ä½ Î²/å¢å¤§ REã€‚`;
    if (App.lastGood){
      computed = deepCopy(App.lastGood.computed);
    } else {
      renderPowerOff("NO SIGNALï¼ˆè®¡ç®—å¤±è´¥ä¸”æ— å¯å›é€€å¿«ç…§ï¼‰");
      setBanner("bad", banner);
      return;
    }
  }
  App.computed = computed;
  if (fsm.mode==="HOLD"){
    App.frozen = deepCopy(computed);
  }
  if (banner) setBanner("bad", banner);
  else if (warn) setBanner("warn", warn);
  else clearBanner();
  renderAllFromComputed(computed);
}

function setBanner(kind, text){
  const b = document.getElementById("globalBanner");
  b.className = "banner " + kind;
  b.textContent = text;
  b.style.display = "block";
}
function clearBanner(){
  const b = document.getElementById("globalBanner");
  b.style.display = "none";
}

/* ----------------------------- Ui_max åº”ç”¨åˆ°æ»‘å—ï¼ˆé˜²æŠ–+é˜²é€’å½’ï¼‰ ----------------------------- */
function applyUiConstraint(bounds){
  const p = currentParams();
  const uiKey = "Ui";
  const range = document.getElementById("paramR_Ui");
  const num = document.getElementById("paramN_Ui");
  if (!range || !num) return;
  const UiMax = Math.max(0, bounds.UiMax);
  const mode = App.state.constraintMode;
  const exploreMax = Math.min(5, UiMax*1.8 + 1e-6);
  const newMax = (mode==="STRICT") ? UiMax : exploreMax;
  App.guard.programmatic = true;
  range.max = newMax;
  num.max = newMax;
  if (mode==="STRICT"){
    if (p.Ui > UiMax){
      p.Ui = UiMax;
      range.value = p.Ui;
      num.value = p.Ui;
    }
  }
  App.guard.programmatic = false;
}

function applyDynamicUiMaxToControls(){
  const c = App.computed || App.frozen;
  if (!c || !c.bounds) return;
  applyUiConstraint(c.bounds);
}

/* ----------------------------- æ¸²æŸ“ï¼šKPI é¢æ¿ ----------------------------- */
function renderKPIs(computed){
  const kpiPanel = document.getElementById("kpiPanel");
  const p = currentParams();
  const dc = computed.dc;
  const wf = computed.wf;
  const b = computed.bounds;
  const reasonText = {
    none:"â€”",
    cutoff:"cutoffï¼ˆæˆªæ­¢ï¼‰",
    saturation:"saturationï¼ˆé¥±å’Œï¼‰",
    overcurrent:"overcurrentï¼ˆè¿‡æµï¼‰",
    overpower:"overpowerï¼ˆåŠŸè€—ï¼‰",
  }[b.limitingReason] || b.limitingReason;
  const m = (p.uoMode==="AC") ? wf.metrics.ac : wf.metrics.node;
  const uoPP = m.pp;
  const uoRms = m.rms;
  const clip = wf.clipInfo;
  let clipMsg = "æ— å‰Šé¡¶";
  if (clip.clipType==="single") clipMsg = `å•è¾¹å‰Šé¡¶ï¼ˆ${clip.firstClip==="cutoff-first"?"å…ˆæˆªæ­¢":"å…ˆé¥±å’Œ"}ï¼‰`;
  if (clip.clipType==="both") clipMsg = `åŒè¾¹å‰Šé¡¶ï¼ˆæˆªæ­¢+é¥±å’Œï¼‰`;
  const region = dc.region;
  const regionZh = {active:"æœ‰æº", cutoff:"æˆªæ­¢", saturation:"é¥±å’Œ", invalid:"å¼‚å¸¸"}[region] || region;
  const items = [
    {t:"çŠ¶æ€", v: App.state.fsm.mode==="OFF" ? "POWER OFF" : (App.state.fsm.mode==="HOLD" ? "HOLD" : "RUN"), s: App.state.pending ? "ï¼ˆæœ‰æœªåº”ç”¨å‚æ•°ï¼‰" : ""},
    {t:"Q ç‚¹ï¼šVCEQ", v: fmtV(dc.VCEQ), s:`VC=${fmtV(dc.VC)}  VE=${fmtV(dc.VE)}`},
    {t:"Q ç‚¹ï¼šICQ", v: fmtA(dc.ICQ), s:`IBQ=${fmtA(dc.IBQ)}  IEQ=${fmtA(dc.IEQ)}`},
    {t:"å·¥ä½œåŒº", v: regionZh, s:`VBEQ=${fmtV(dc.VBEQ)}`},
    {t:"Ui_maxï¼ˆç‰µåˆ¶ï¼‰", v: fmtV(b.UiMax), s:`ä¸»å¯¼åŸå› ï¼š${reasonText}`},
    {t:"è¾“å‡ºå¹…åº¦ï¼ˆå½“å‰ï¼‰", v: `${formatSI(uoPP,"V",3)}pp`, s:`Vrms=${formatSI(uoRms,"V",3)}ï¼ˆ${p.uoMode==="AC"?"ACè€¦åˆ":"å«ç›´æµ"}ï¼‰`},
    {t:"å¤±çœŸ/å‰Šé¡¶", v: clipMsg, s:`ä¸€è‡´æ€§ï¼šmean(VCE)â‰ˆVCEQ ${computed.consistencyOk?"âœ“":"âœ—"}ï¼ˆerr ${(computed.consistencyRelErr*100).toFixed(1)}%ï¼‰`},
  ];
  kpiPanel.innerHTML = items.map(it=>`
    <div class="kpi">
      <div class="t">${it.t}</div>
      <div class="v">${it.v}</div>
      <div class="s">${it.s||""}</div>
    </div>
  `).join("");
}

/* ----------------------------- æ¸²æŸ“ï¼šå›¾è¡¨ï¼ˆPlotlyï¼‰ ----------------------------- */
function renderAllFromComputed(computed){
  const fsm = App.state.fsm;
  const circuit = App.state.circuit;
  const p = currentParams();
  const dc = computed.dc;
  const chars = computed.chars;
  const wf = computed.wf;
  const svgWrap = document.getElementById("svgWrap");
  svgWrap.innerHTML = svgForCircuit(circuit, p, dc, fsm.mode);
  const wmTag = document.getElementById("wmTag");
  wmTag.textContent = (fsm.mode==="OFF") ? "NO SIGNAL" : (fsm.mode==="HOLD" ? "HOLD" : "RUN");
  wmTag.className = "watermark " + ((fsm.mode==="OFF") ? "wm-nosig" : (fsm.mode==="HOLD" ? "wm-hold" : "wm-run"));
  renderKPIs(computed);
  const tms = wf.t.map(tt=> tt*1000);
  const uiTrace = {
    x: tms, y: wf.ui,
    type:"scatter", mode:"lines",
    name:"ui(t)", line:{width:2, color:"#5ad7ff"},
    hovertemplate:"t=%{x:.2f} ms<br>ui=%{y:.4f} V<extra></extra>",
  };
  const lUi = plotLayoutBase("è¾“å…¥æ³¢å½¢ ui(t)", "t (ms)", "ui (V)");
  lUi.uirevision = "ui";
  if (p.autoScale!=="ON"){
    lUi.yaxis.range = [-Math.max(0.02, p.Ui*1.35), Math.max(0.02, p.Ui*1.35)];
  }
  Plotly.react("plotUi", [uiTrace], lUi, {displayModeBar:false, responsive:true});
  const uoArr = (p.uoMode==="AC") ? wf.uoAC : wf.uoNode;
  const uoTrace = {
    x: tms, y: uoArr,
    type:"scatter", mode:"lines",
    name: (p.uoMode==="AC") ? "uo(t) AC" : "uo(t) NODE",
    line:{width:2, color:"#2ee59d"},
    hovertemplate:"t=%{x:.2f} ms<br>uo=%{y:.4f} V<extra></extra>",
  };
  const lUo = plotLayoutBase("è¾“å‡ºæ³¢å½¢ uo(t)", "t (ms)", "uo (V)");
  lUo.uirevision = "uo";
  if (p.autoScale!=="ON"){
    if (p.uoMode==="AC"){
      const amp = Math.max(0.05, Math.max(...uoArr.map(v=>Math.abs(v))) * 1.25);
      lUo.yaxis.range = [-amp, amp];
    } else {
      lUo.yaxis.range = [Math.min(0, dc.VE-0.5), Math.max(p.VCC, dc.VC+0.5)];
    }
  }
  if (wf.clipInfo.clipType!=="none"){
    lUo.annotations = [{
      text: wf.clipInfo.clipType==="both" ? "CLIPPING: cutoff + saturation" : `CLIPPING: ${wf.clipInfo.anyCut?"cutoff":"saturation"}`,
      x:0.02, y:0.95, xref:"paper", yref:"paper", showarrow:false,
      font:{size:12, color:"rgba(255,204,102,.95)"},
      bgcolor:"rgba(0,0,0,.25)",
      bordercolor:"rgba(255,204,102,.35)",
      borderwidth:1,
      align:"left"
    }];
  }
  Plotly.react("plotUo", [uoTrace], lUo, {displayModeBar:false, responsive:true});
  const inCurve = {
    x: chars.inputCurve.x, y: chars.inputCurve.y,
    type:"scatter", mode:"lines",
    name:"è¾“å…¥ç‰¹æ€§",
    line:{width:2, color:"#5ad7ff"},
    hovertemplate:`${chars.inputCurve.xLabel}=%{x:.3f}<br>${chars.inputCurve.yLabel}=%{y:.4e}<extra></extra>`,
  };
  const inQ = {
    x:[chars.inputCurve.q.x], y:[chars.inputCurve.q.y],
    type:"scatter", mode:"markers+text",
    name:"Q ç‚¹",
    marker:{size:10, color:"#ffcc66", line:{width:1, color:"#111"}},
    text:["Q"], textposition:"top center",
    hovertemplate:"Q ç‚¹<br>x=%{x:.3f}<br>y=%{y:.4e}<extra></extra>"
  };
  const lIn = plotLayoutBase(chars.inputCurve.title, chars.inputCurve.xLabel, chars.inputCurve.yLabel);
  lIn.uirevision = "in";
  Plotly.react("plotIn", [inCurve, inQ], lIn, {displayModeBar:false, responsive:true});
  const xUi = wf.ui;
  const yUo = (p.uoMode==="AC") ? wf.uoAC : wf.uoNode;
  const idxSorted = [...Array(xUi.length).keys()].sort((a,b)=> Math.abs(xUi[a]) - Math.abs(xUi[b]));
  const take = Math.max(30, Math.floor(xUi.length*0.25));
  const idxTake = idxSorted.slice(0, take);
  let sx=0, sy=0, sxx=0, sxy=0;
  for (const i of idxTake){
    const x = xUi[i], y = yUo[i];
    sx += x; sy += y; sxx += x*x; sxy += x*y;
  }
  const nfit = idxTake.length;
  const denom = (nfit*sxx - sx*sx);
  const k = denom!==0 ? (nfit*sxy - sx*sy)/denom : 0;
  const b0 = (sy - k*sx)/Math.max(1, nfit);
  const xFit = [Math.min(...xUi), Math.max(...xUi)];
  const yFit = xFit.map(x=> k*x + b0);
  const tr1 = {
    x: xUi, y: yUo,
    type:"scatter", mode:"lines",
    name:"åŠ¨æ€è½¬ç§»æ›²çº¿",
    line:{width:2, color:"#2ee59d"},
    hovertemplate:"ui=%{x:.4f} V<br>uo=%{y:.4f} V<extra></extra>",
  };
  const trFit = {
    x: xFit, y: yFit,
    type:"scatter", mode:"lines",
    name:"è¿‘ä¼¼çº¿æ€§æ®µï¼ˆæ‹Ÿåˆï¼‰",
    line:{width:2, dash:"dot", color:"#ffcc66"},
    hovertemplate:"çº¿æ€§æ‹Ÿåˆ<extra></extra>",
  };
  const lTr = plotLayoutBase("ä¼ è¾“ç‰¹æ€§ uo â€“ uiï¼ˆåŠ¨æ€ï¼‰", "ui (V)", (p.uoMode==="AC")?"uo_AC (V)":"uo_node (V)");
  lTr.uirevision = "tr";
  Plotly.react("plotTransfer", [tr1, trFit], lTr, {displayModeBar:false, responsive:true});
  const traces = [];
  for (const c of chars.outputCurves.curves){
    const ib = c.ib;
    const name = (ib===0) ? "IB=0" : `IB=${formatSI(ib,"A",3)}`;
    traces.push({
      x: c.vce, y: c.ic,
      type:"scatter", mode:"lines",
      name, line:{width:1.5, color:"rgba(233,238,255,.55)"},
      hovertemplate:"VCE=%{x:.2f} V<br>IC=%{y:.4e} A<extra></extra>"
    });
  }
  traces.push({
    x: chars.loadLines.dc.VCE, y: chars.loadLines.dc.IC,
    type:"scatter", mode:"lines",
    name:"ç›´æµè´Ÿè½½çº¿",
    line:{width:2, color:"#5ad7ff"},
    hovertemplate:"DC load line<extra></extra>"
  });
  traces.push({
    x: chars.loadLines.ac.VCE, y: chars.loadLines.ac.IC,
    type:"scatter", mode:"lines",
    name:"äº¤æµè´Ÿè½½çº¿ï¼ˆè¿‡ Qï¼‰",
    line:{width:2, dash:"dash", color:"#2ee59d"},
    hovertemplate:"AC load line<extra></extra>"
  });
  traces.push({
    x:[dc.VCEQ], y:[dc.ICQ],
    type:"scatter", mode:"markers+text",
    name:"Q ç‚¹",
    marker:{size:12, color:"#ffcc66", line:{width:1, color:"#111"}},
    text:["Q"], textposition:"top center",
  });
  traces.push({
    x: wf.vce, y: wf.ic,
    type:"scatter", mode:"lines",
    name:"ç¬æ—¶è½¨è¿¹ (VCE(t),IC(t))",
    line:{width:2, color:"rgba(255,204,102,.55)"},
    hovertemplate:"VCE=%{x:.2f} V<br>IC=%{y:.4e} A<extra></extra>"
  });
  const lOut = plotLayoutBase("è¾“å‡ºç‰¹æ€§æ—ï¼šIC â€“ VCEï¼ˆå«è´Ÿè½½çº¿/Q ç‚¹/è½¨è¿¹/å·¥ä½œåŒºï¼‰", "VCE (V)", "IC (A)");
  lOut.uirevision = "out";
  lOut.shapes = [];
  lOut.shapes.push({
    type:"rect", xref:"x", yref:"paper",
    x0:0, x1: chars.regions.saturation.x1, y0:0, y1:1,
    fillcolor:"rgba(255,77,109,.08)", line:{width:0}, layer:"below"
  });
  lOut.shapes.push({
    type:"rect", xref:"paper", yref:"y",
    x0:0, x1:1, y0:0, y1: chars.regions.cutoffIC,
    fillcolor:"rgba(180,190,220,.07)", line:{width:0}, layer:"below"
  });
  lOut.annotations = [
    {
      text:`è£•é‡ï¼šåˆ°æˆªæ­¢ â‰ˆ ${fmtV(chars.loadLines.margins.marginToCutoff)} ï¼Œåˆ°é¥±å’Œ â‰ˆ ${fmtV(chars.loadLines.margins.marginToSat)}`,
      x:0.02, y:0.98, xref:"paper", yref:"paper", showarrow:false,
      font:{size:12, color:"rgba(233,238,255,.85)"},
      bgcolor:"rgba(0,0,0,.22)", bordercolor:"rgba(255,255,255,.12)", borderwidth:1,
      align:"left"
    },
    {
      text:`å·¥ä½œåŒºï¼šcutoff / active / saturation`,
      x:0.02, y:0.90, xref:"paper", yref:"paper", showarrow:false,
      font:{size:11, color:"rgba(170,179,214,.9)"},
      bgcolor:"rgba(0,0,0,.18)", bordercolor:"rgba(255,255,255,.10)", borderwidth:1,
      align:"left"
    }
  ];
  Plotly.react("plotOut", traces, lOut, {displayModeBar:false, responsive:true});
  applyDynamicUiMaxToControls();
  updateLiveDiag(computed);
}

/* ----------------------------- Power OFF æ˜¾ç¤ºï¼ˆNO SIGNALï¼‰ ----------------------------- */
function renderPowerOff(customText){
  const txt = customText || "NO SIGNAL";
  const p = currentParams();
  const circuit = App.state.circuit;
  const dcDummy = {VCEQ:NaN, ICQ:NaN, IBQ:NaN, IEQ:NaN, VC:NaN, VE:NaN, VBEQ:NaN, region:"off"};
  document.getElementById("svgWrap").innerHTML = svgForCircuit(circuit, p, dcDummy, "OFF");
  const wmTag = document.getElementById("wmTag");
  wmTag.textContent = "NO SIGNAL";
  wmTag.className = "watermark wm-nosig";
  document.getElementById("kpiPanel").innerHTML = `
    <div class="kpi"><div class="t">çŠ¶æ€</div><div class="v">POWER OFF</div><div class="s">NO SIGNAL</div></div>
    <div class="kpi"><div class="t">æç¤º</div><div class="v">æ‰“å¼€ Power</div><div class="s">HOLD åœ¨ Power ON æ—¶æ‰ç”Ÿæ•ˆ</div></div>
  `;
  const offLayout = (title,x,y)=> {
    const l = plotLayoutBase(title,x,y);
    l.annotations = annotateCenter(txt);
    l.showlegend = false;
    return l;
  };
  Plotly.react("plotUi", [{x:[0,1],y:[0,0],type:"scatter",mode:"lines",line:{width:2,color:"rgba(180,190,220,.5)"}}], offLayout("è¾“å…¥æ³¢å½¢ ui(t)", "t", "ui"), {displayModeBar:false, responsive:true});
  Plotly.react("plotUo", [{x:[0,1],y:[0,0],type:"scatter",mode:"lines",line:{width:2,color:"rgba(180,190,220,.5)"}}], offLayout("è¾“å‡ºæ³¢å½¢ uo(t)", "t", "uo"), {displayModeBar:false, responsive:true});
  Plotly.react("plotIn", [], offLayout("è¾“å…¥ç‰¹æ€§ï¼ˆç°ç½®ï¼‰", "V", "I"), {displayModeBar:false, responsive:true});
  Plotly.react("plotTransfer", [], offLayout("ä¼ è¾“ç‰¹æ€§ï¼ˆç°ç½®ï¼‰", "ui", "uo"), {displayModeBar:false, responsive:true});
  Plotly.react("plotOut", [], offLayout("è¾“å‡ºç‰¹æ€§ï¼ˆç°ç½®ï¼‰", "VCE", "IC"), {displayModeBar:false, responsive:true});
  updateLiveDiag();
}

/* ----------------------------- RUNï¼šç›¸ä½æ»šåŠ¨ï¼ˆä¸é‡ç®—ï¼Œåªå¾ªç¯ç§»ä½ï¼‰ ----------------------------- */
function startRunLoop(){
  function tick(ts){
    requestAnimationFrame(tick);
    const fsm = App.state.fsm;
    if (fsm.mode!=="RUN") return;
    if (!App.computed) return;
    if (ts - App.run.lastFrameMs < App.run.throttleMs) return;
    App.run.lastFrameMs = ts;
    const p = currentParams();
    const wf = App.computed.wf;
    const n = wf.t.length;
    const cycles = Math.max(1, Math.round(p.cycles||2));
    const perCycle = Math.max(1, Math.floor(n / cycles));
    const dt = App.run.throttleMs / 1000;
    const dShift = Math.max(1, Math.floor(perCycle * p.f * dt));
    App.run.shift = (App.run.shift + dShift) % n;
    const shiftArr = (arr)=>{
      const k = App.run.shift;
      return arr.slice(k).concat(arr.slice(0,k));
    };
    const tms = wf.t.map(tt=> tt*1000);
    const tmsShift = shiftArr(tms);
    const uiShift = shiftArr(wf.ui);
    const uoShift = shiftArr((p.uoMode==="AC") ? wf.uoAC : wf.uoNode);
    Plotly.restyle("plotUi", {x:[tmsShift], y:[uiShift]}, [0]);
    Plotly.restyle("plotUo", {x:[tmsShift], y:[uoShift]}, [0]);
  }
  requestAnimationFrame(tick);
}

/* ----------------------------- è¯Šæ–­ï¼šè¿è¡Œä¸­æç¤ºï¼ˆå‘Šè­¦/å»ºè®®ï¼‰ ----------------------------- */
function updateLiveDiag(computed){
  const el = document.getElementById("liveDiag");
  const fsm = App.state.fsm;
  const p = currentParams();
  if (fsm.mode==="OFF"){
    el.innerHTML = `çŠ¶æ€ï¼š<b>POWER OFF</b>ã€‚å›¾è¡¨å¤„äº NO SIGNALã€‚<br><span class="muted">æç¤ºï¼šæ‰“å¼€ Power åå¼€å§‹è®¡ç®—ï¼›è‹¥ HOLD=ONï¼Œä¸Šç”µåä¼šè®¡ç®—ä¸€æ¬¡å¹¶å†»ç»“ã€‚</span>`;
    return;
  }
  const c = computed || App.frozen || App.computed;
  if (!c){
    el.textContent = "æš‚æ— è®¡ç®—ç»“æœã€‚";
    return;
  }
  const dc = c.dc, wf = c.wf, b = c.bounds;
  const lines = [];
  lines.push(`çŠ¶æ€ï¼š<b>${fsm.mode}</b>ï¼ˆç‰µåˆ¶ï¼š<b>${App.state.constraintMode}</b>ï¼Œæ¨¡å‹ï¼š<b>${App.state.modelMode}</b>ï¼‰`);
  lines.push(`Qï¼šVCEQ=${fmtV(dc.VCEQ)}ï¼ŒICQ=${fmtA(dc.ICQ)}ï¼Œå·¥ä½œåŒº=${dc.region}`);
  lines.push(`Ui=${fmtV(p.Ui)}ï¼ˆUi_maxâ‰ˆ${fmtV(b.UiMax)}ï¼Œä¸»å¯¼=${b.limitingReason || "â€”"}ï¼‰`);
  lines.push(`å‰Šé¡¶ï¼š${wf.clipInfo.clipType}ï¼ˆ${wf.clipInfo.anyCut?"cutoff ":""}${wf.clipInfo.anySat?"saturation":""}ï¼‰`);
  if (App.state.constraintMode==="EXPLORE" && p.Ui > b.UiMax*1.001){
    lines.push(`<span style="color:#ffcc66;font-weight:800;">âš  æ¢ç´¢æ¨¡å¼è¶…é™ï¼šUi > Ui_max</span>ï¼ˆä¼šæ¼”ç¤ºå¤±çœŸ/è¿‡è½½ï¼‰ã€‚å»ºè®®æŸ¥çœ‹ä¸»å¯¼åŸå› å¹¶è°ƒå‚ã€‚`);
  }
  const maxIC = Math.max(...wf.ic);
  const maxP = Math.max(...wf.vce.map((v,i)=>Math.max(0,v)*Math.max(0,wf.ic[i])));
  if (maxIC > p.IC_max*1.001){
    lines.push(`<span style="color:#ff4d6d;font-weight:800;">âš  è¿‡æµï¼šmax(IC)â‰ˆ${fmtA(maxIC)} > IC_max=${fmtA(p.IC_max)}</span>`);
  }
  if (maxP > p.P_max*1.001){
    lines.push(`<span style="color:#ff4d6d;font-weight:800;">âš  è¿‡åŠŸè€—ï¼šmax(P)â‰ˆ${fmtW(maxP)} > P_max=${fmtW(p.P_max)}</span>`);
  }
  if (fsm.mode==="HOLD" && App.state.pending){
    lines.push(`<span style="color:#ffcc66;font-weight:800;">å·²å†»ç»“ï¼šè§£é™¤ HOLD åå°†åº”ç”¨æ–°å‚æ•°</span>`);
  }
  lines.push(`<span class="muted">åˆ·æ–°è€—æ—¶ï¼š${c.perfMs ? c.perfMs.toFixed(1) : "â€”"} msï¼ˆè‡ªæµ‹è¦æ±‚ < 50msï¼‰</span>`);
  el.innerHTML = lines.join("<br/>");
}

/* ----------------------------- é¢„è®¾ & è‡ªåŠ¨åŒ– ----------------------------- */
function fillPresetSelect(){
  const sel = document.getElementById("presetSelect");
  sel.innerHTML = "";
  for (const ps of PRESETS){
    const o = document.createElement("option");
    o.value = ps.id;
    o.textContent = ps.name;
    sel.appendChild(o);
  }
}
function applyPresetById(id){
  const ps = PRESETS.find(x=>x.id===id);
  if (!ps) return;
  App.state.circuit = ps.circuit;
  document.getElementById("circuitSelect").value = ps.circuit;
  const p = App.paramsByCircuit[ps.circuit];
  ps.apply(p);
  buildParamPanel();
  if (App.state.fsm.mode!=="OFF" && App.state.fsm.mode!=="HOLD") computeAndRenderSafe();
  else renderPowerOff();
}
function autoBiasCenter(){
  const circuit = App.state.circuit;
  const p = currentParams();
  if (App.state.fsm.mode==="OFF"){
    setBanner("warn", "Power OFFï¼šä»å¯è‡ªåŠ¨è®¾å®š VBQï¼Œä½†å›¾ä¸ä¼šæ›´æ–°ã€‚æ‰“å¼€ Power åç”Ÿæ•ˆã€‚");
  }
  const target = (p.VCC + p.VCEsat)/2;
  const vbMin = 0.2, vbMax = 3.2;
  function evalVB(vb){
    const pp = deepCopy(p);
    pp.VBQ = vb;
    const dc = solveDC(pp, circuit);
    if (!dc.ok) return {ok:false, err:1e9};
    return {ok:true, err: dc.VCEQ - target, dc};
  }
  let a=vbMin, b=vbMax;
  let fa = evalVB(a), fb = evalVB(b);
  if (!fa.ok || !fb.ok){
    setBanner("warn", "è‡ªåŠ¨å±…ä¸­ï¼šåœ¨ VBQ è¾¹ç•Œå¤„ DC æ— è§£ã€‚å»ºè®®å¢å¤§ RE/RC æˆ–å‡å° VBQ èŒƒå›´ã€‚");
    return;
  }
  if (fa.err*fb.err > 0){
    let best = {vb:a, e:Math.abs(fa.err)};
    for (let i=0;i<=40;i++){
      const vb = lerp(vbMin, vbMax, i/40);
      const r = evalVB(vb);
      if (r.ok && Math.abs(r.err) < best.e){
        best = {vb, e:Math.abs(r.err)};
      }
    }
    p.VBQ = best.vb;
    buildParamPanel();
    if (App.state.fsm.mode==="RUN") computeAndRenderSafe();
    else App.state.pending = true;
    setBanner("warn", `è‡ªåŠ¨å±…ä¸­ï¼šæœªèƒ½ä¸¥æ ¼äºŒåˆ†æ‹¬ä½ç›®æ ‡ï¼Œå·²é€‰è¿‘ä¼¼æœ€ä¼˜ VBQâ‰ˆ${fmtV(best.vb)}ã€‚`);
    return;
  }
  for (let i=0;i<18;i++){
    const m = 0.5*(a+b);
    const fm = evalVB(m);
    if (!fm.ok) { b = m; continue; }
    if (fa.err*fm.err <= 0){
      b = m; fb = fm;
    } else {
      a = m; fa = fm;
    }
  }
  const vbBest = 0.5*(a+b);
  p.VBQ = vbBest;
  buildParamPanel();
  if (App.state.fsm.mode==="RUN") computeAndRenderSafe();
  else App.state.pending = true;
  clearBanner();
}
function autoJustNoDist(){
  const circuit = App.state.circuit;
  const p = currentParams();
  const Ui = p.Ui;
  const vbMin = 0.2, vbMax = 3.2;
  function scoreVB(vb){
    const pp = deepCopy(p);
    pp.VBQ = vb;
    const dc = solveDC(pp, circuit);
    if (!dc.ok) return {ok:false, score:1e9, why:"DCæ— è§£"};
    const wf = genWaveforms(pp, circuit, dc, "FAST");
    const minVCE = Math.min(...wf.vce);
    const maxVCE = Math.max(...wf.vce);
    const a = (minVCE - p.VCEsat);
    const b = (p.VCC - maxVCE);
    const clipPenalty = (wf.clipInfo.anyCut || wf.clipInfo.anySat) ? 10 : 0;
    const asym = Math.abs(a-b);
    const negPenalty = (a<0? 50*Math.abs(a):0) + (b<0? 50*Math.abs(b):0);
    return {ok:true, score: asym + negPenalty + clipPenalty, a,b, dc, wf};
  }
  let best = {score:1e18, vb:p.VBQ};
  const steps = 50;
  for (let i=0;i<=steps;i++){
    const vb = lerp(vbMin, vbMax, i/steps);
    const r = scoreVB(vb);
    if (r.ok && r.score < best.score){
      best = {score:r.score, vb, a:r.a, b:r.b};
    }
  }
  p.VBQ = best.vb;
  buildParamPanel();
  if (App.state.fsm.mode==="RUN") computeAndRenderSafe();
  else App.state.pending = true;
  setBanner("warn", `åˆšå¥½ä¸å¤±çœŸï¼šå·²é€‰ VBQâ‰ˆ${fmtV(best.vb)}ï¼ˆåœ¨å½“å‰ Ui=${fmtV(Ui)} ä¸‹è®©ä¸Šä¸‹è£•é‡æ›´æ¥è¿‘ï¼‰ã€‚è‹¥ä»è½»å¾®å‰Šé¡¶ï¼Œå°è¯•ç•¥å‡ Ui æˆ–å¢å¤§ RLã€‚`);
}

/* ----------------------------- Export/Import/Reset/Revert/PNG ----------------------------- */
function resetAll(){
  App.paramsByCircuit.CE = defaultParamsCE();
  App.paramsByCircuit.CC = defaultParamsCC();
  App.paramsByCircuit.CB = defaultParamsCB();
  App.state.pending = false;
  document.getElementById("pendingHint").style.display = "none";
  buildParamPanel();
  if (App.state.fsm.mode==="RUN" || App.state.fsm.mode==="HOLD") computeAndRenderSafe();
  else renderPowerOff();
}
function revertLastGood(){
  if (!App.lastGood){
    setBanner("warn", "æš‚æ—  last-known-good å¿«ç…§ã€‚è¯·å…ˆ Power ON è¿è¡Œä¸€æ¬¡ã€‚");
    return;
  }
  App.paramsByCircuit = deepCopy(App.lastGood.params);
  App.state.circuit = App.lastGood.circuit;
  document.getElementById("circuitSelect").value = App.state.circuit;
  App.state.pending = false;
  document.getElementById("pendingHint").style.display = "none";
  buildParamPanel();
  if (App.state.fsm.mode==="OFF") renderPowerOff();
  else {
    App.computed = deepCopy(App.lastGood.computed);
    renderAllFromComputed(App.computed);
    clearBanner();
  }
}
function exportJSON(){
  const payload = {
    version: "bjt-teaching-tool-1.0",
    savedAt: new Date().toISOString(),
    app: {
      circuit: App.state.circuit,
      modelMode: App.state.modelMode,
      constraintMode: App.state.constraintMode,
      fsm: App.state.fsm,
    },
    paramsByCircuit: App.paramsByCircuit,
  };
  const blob = new Blob([JSON.stringify(payload, null, 2)], {type:"application/json"});
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = "bjt_teaching_tool_state.json";
  document.body.appendChild(a);
  a.click();
  a.remove();
  URL.revokeObjectURL(url);
}
async function importJSONFile(file){
  const text = await file.text();
  let obj;
  try{ obj = JSON.parse(text); }catch(e){
    setBanner("bad", "Import å¤±è´¥ï¼šJSON è§£æé”™è¯¯ã€‚");
    return;
  }
  if (!obj || !obj.paramsByCircuit){
    setBanner("bad", "Import å¤±è´¥ï¼šç¼ºå°‘ paramsByCircuitã€‚");
    return;
  }
  App.paramsByCircuit = deepCopy(obj.paramsByCircuit);
  if (obj.app){
    App.state.circuit = obj.app.circuit || App.state.circuit;
    App.state.modelMode = obj.app.modelMode || App.state.modelMode;
    App.state.constraintMode = obj.app.constraintMode || App.state.constraintMode;
    document.getElementById("modelSelect").value = App.state.modelMode;
    document.getElementById("constraintSelect").value = App.state.constraintMode;
  }
  document.getElementById("circuitSelect").value = App.state.circuit;
  buildParamPanel();
  setBanner("warn", "å·²å¯¼å…¥å‚æ•°ã€‚è‹¥å¤„äº HOLDï¼Œå°†åœ¨è§£é™¤ HOLD ååº”ç”¨åˆ°å›¾åƒã€‚ ");
  if (App.state.fsm.mode==="RUN") computeAndRenderSafe();
  if (App.state.fsm.mode==="OFF") renderPowerOff();
}
function exportPNGWave(){
  Plotly.downloadImage("plotUo", {format:"png", filename:"uo_waveform"});
  setTimeout(()=> Plotly.downloadImage("plotUi", {format:"png", filename:"ui_waveform"}), 350);
}
function exportPNGChar(){
  Plotly.downloadImage("plotOut", {format:"png", filename:"output_characteristics"});
  setTimeout(()=> Plotly.downloadImage("plotIn", {format:"png", filename:"input_characteristics"}), 350);
}

/* ----------------------------- Power/HOLD æŒ‰é’®é€»è¾‘ ----------------------------- */
function updatePowerHoldButtons(){
  const pBtn = document.getElementById("powerBtn");
  const hBtn = document.getElementById("holdBtn");
  const s = App.state.fsm;
  pBtn.textContent = s.powerSwitch ? "ON" : "OFF";
  pBtn.className = "toggle " + (s.powerSwitch ? "on" : "off");
  hBtn.textContent = s.holdSwitch ? "ON" : "OFF";
  hBtn.className = "toggle " + (s.holdSwitch ? "on" : "off");
  hBtn.style.opacity = s.powerSwitch ? "1" : "0.85";
}
function setFSM(event){
  const prevMode = App.state.fsm.mode;
  App.state.fsm = fsmTransition(App.state.fsm, event);
  updatePowerHoldButtons();
  const newMode = App.state.fsm.mode;
  if (newMode==="OFF"){
    App.state.pending = false;
    document.getElementById("pendingHint").style.display = "none";
    App.frozen = null;
    renderPowerOff();
    return;
  }
  if (newMode==="HOLD"){
    App.state.pending = false;
    document.getElementById("pendingHint").style.display = "none";
    computeAndRenderSafe();
    return;
  }
  if (newMode==="RUN"){
    App.state.pending = false;
    document.getElementById("pendingHint").style.display = "none";
    App.frozen = null;
    computeAndRenderSafe();
  }
}

/* ----------------------------- è‡ªæµ‹ï¼ˆå¿…é¡»çœŸå®è¿è¡Œå¹¶æ˜¾ç¤º PASS/FAILï¼‰ ----------------------------- */
function addTestItem(title, pass, details){
  App.selfTest.items.push({title, pass, details});
}
function renderTests(){
  const panel = document.getElementById("testPanel");
  panel.innerHTML = "";
  for (const it of App.selfTest.items){
    const div = document.createElement("div");
    div.className = "testItem";
    div.innerHTML = `
      <div class="top">
        <div style="font-weight:850;">${it.title}</div>
        <span class="pill ${it.pass ? "pass" : "fail"}">${it.pass ? "PASS" : "FAIL"}</span>
      </div>
      <div class="subtle">${it.details}</div>
    `;
    panel.appendChild(div);
  }
  if (App.selfTest.failCount>0){
    setBanner("bad", `SELF-TEST FAILEDï¼šå…± ${App.selfTest.failCount} é¡¹å¤±è´¥ã€‚è¯·æŸ¥çœ‹å³ä¾§é¢æ¿çš„ FAIL è§£é‡Šä¸å»ºè®®ã€‚`);
  }
}
function runSelfTests(){
  App.selfTest = {done:false, failCount:0, items:[]};
  try{
    const s0 = {powerSwitch:false, holdSwitch:false, mode:"OFF"};
    const s1 = fsmTransition(s0, {type:"SET_HOLD", value:true});
    const s2 = fsmTransition(s1, {type:"SET_POWER", value:true});
    const s3 = fsmTransition(s2, {type:"SET_POWER", value:false});
    const ok = (s1.mode==="OFF") && (s2.mode==="HOLD") && (s3.mode==="OFF");
    addTestItem("çŠ¶æ€æœºï¼šPower/HOLD ä¼˜å…ˆçº§ + OFF=NO SIGNAL", ok,
      ok ? "HOLD åœ¨ Power OFF æ—¶ä¸ç”Ÿæ•ˆï¼›OFFâ†’ON ä¸” HOLD=ON åº”è¿›å…¥ HOLDï¼›ONâ†’OFF æ°¸è¿œ OFFã€‚"
         : `æœŸæœ›ï¼šOFF->(hold on)ä»OFFï¼ŒON+hold=HOLDï¼ŒOFFä¼˜å…ˆã€‚å®é™…ï¼š${JSON.stringify({s1,s2,s3})}`);
    if (!ok) App.selfTest.failCount++;
  } catch(e){
    addTestItem("çŠ¶æ€æœºï¼šPower/HOLD", false, "å¼‚å¸¸ï¼š" + String(e));
    App.selfTest.failCount++;
  }
  const dcTests = [
    {c:"CE", p: defaultParamsCE()},
    {c:"CE", p: {...defaultParamsCE(), VBQ:1.6}},
    {c:"CC", p: defaultParamsCC()},
    {c:"CC", p: {...defaultParamsCC(), VBQ:1.2}},
    {c:"CB", p: defaultParamsCB()},
    {c:"CB", p: {...defaultParamsCB(), VBQ:2.2}},
  ];
  let dcOk = true;
  let dcMsg = [];
  for (const t of dcTests){
    const dc = solveDC(t.p, t.c);
    const ok = dc.ok && isFiniteNum(dc.VCEQ) && isFiniteNum(dc.ICQ) && dc.ICQ>=0 && dc.VCEQ>-0.5;
    dcOk = dcOk && ok;
    dcMsg.push(`${t.c}: ${ok?"ok":"bad"} (VCEQ=${dc.VCEQ?.toFixed(2)}, ICQ=${dc.ICQ?.toExponential(2)}, region=${dc.region})`);
  }
  addTestItem("DC æ±‚è§£ï¼šä¸‰ç”µè·¯ â‰¥6 ä¾‹æ—  NaN/Inf ä¸” region åˆç†", dcOk, dcMsg.join("<br/>"));
  if (!dcOk) App.selfTest.failCount++;
  try{
    const p = defaultParamsCE();
    const dc = solveDC(p, "CE");
    const Uis = [0.01, 0.08, 0.18];
    const clips = [];
    for (const u of Uis){
      const wf = genWaveforms({...p, Ui:u, cycles:1, samples:260}, "CE", dc, "FAST");
      clips.push(wf.clipInfo.clipType);
    }
    const unique = new Set(clips);
    const ok = unique.has("none") && (unique.has("single") || unique.has("both"));
    addTestItem("å‰Šé¡¶æ¼”åŒ–ï¼ˆCEï¼‰ï¼šUi å¢å¤§åº”å‡ºç° none / å•è¾¹æˆ–åŒè¾¹", ok,
      `é‡‡æ · Ui=${Uis.map(fmtV).join(", ")} â†’ clipType=${clips.join(" â†’ ")}ã€‚` +
      (ok ? "" : "å»ºè®®ï¼šå¢å¤§ Ui æˆ–è°ƒæ•´åç½® VBQ è®© Q ç‚¹é è¾¹ï¼Œä»¥æ›´æ˜æ˜¾è§¦å‘å‰Šé¡¶ã€‚"));
    if (!ok) App.selfTest.failCount++;
  } catch(e){
    addTestItem("å‰Šé¡¶æ¼”åŒ–ï¼ˆCEï¼‰", false, "å¼‚å¸¸ï¼š" + String(e));
    App.selfTest.failCount++;
  }
  try{
    const base = defaultParamsCE();
    const dc = solveDC(base, "CE");
    const b0 = calcDynamicBounds(base, "CE", dc).UiMax;
    const p1 = {...base, RL:2000};
    const dc1 = solveDC(p1, "CE");
    const b1 = calcDynamicBounds(p1, "CE", dc1).UiMax;
    const p2 = {...base, RC:1000};
    const dc2 = solveDC(p2, "CE");
    const b2 = calcDynamicBounds(p2, "CE", dc2).UiMax;
    const p3 = {...base, RC:1000, RL:2000};
    const dc3 = solveDC(p3, "CE");
    const b3 = calcDynamicBounds(p3, "CE", dc3).UiMax;
    const ok = (b1 <= b0*1.05) && (b2 <= b0*1.05) && (b3 <= b0*1.05);
    addTestItem("åŠ¨æ€ç‰µåˆ¶ï¼šè´Ÿè½½æ›´é‡ï¼ˆRLâ†“/RCâ†“ï¼‰Ui_max ä¸åº”å˜å¤§ï¼ˆå®¹å·® 5%ï¼‰", ok,
      `åŸºå‡† Ui_max=${fmtV(b0)}ï¼›RLâ†“â†’${fmtV(b1)}ï¼›RCâ†“â†’${fmtV(b2)}ï¼›åŒé‡â†’${fmtV(b3)}ã€‚`);
    if (!ok) App.selfTest.failCount++;
  } catch(e){
    addTestItem("åŠ¨æ€ç‰µåˆ¶ï¼ˆUi_maxï¼‰", false, "å¼‚å¸¸ï¼š" + String(e));
    App.selfTest.failCount++;
  }
  try{
    const p = defaultParamsCE();
    const dc = solveDC(p, "CE");
    const wf = genWaveforms({...p, Ui:0.02, cycles:2, samples:420}, "CE", dc, "FAST");
    const rel = Math.abs(wf.clipInfo.meanVCE - dc.VCEQ)/Math.max(1e-6, Math.abs(dc.VCEQ));
    const ok = rel <= 0.02;
    addTestItem("ä¸€è‡´æ€§ï¼šmean(VCE(t)) â‰ˆ VCEQï¼ˆå®¹å·® 2%ï¼‰", ok,
      `mean(VCE)=${fmtV(wf.clipInfo.meanVCE)}ï¼ŒVCEQ=${fmtV(dc.VCEQ)}ï¼Œè¯¯å·® ${(rel*100).toFixed(2)}%ã€‚`);
    if (!ok) App.selfTest.failCount++;
  } catch(e){
    addTestItem("ä¸€è‡´æ€§ï¼šmean(VCE)â‰ˆVCEQ", false, "å¼‚å¸¸ï¼š" + String(e));
    App.selfTest.failCount++;
  }
  try{
    const p = defaultParamsCE();
    const t0 = nowMs();
    const dc = solveDC(p, "CE");
    const b = calcDynamicBounds(p, "CE", dc);
    const ch = genCharacteristics(p, "CE", dc);
    const wf = genWaveforms(p, "CE", dc, "FAST");
    const dt = nowMs()-t0;
    const ok = dt < 50;
    addTestItem("æ€§èƒ½ï¼šä¸€æ¬¡å®Œæ•´è®¡ç®—ï¼ˆDC+ç‰µåˆ¶+ç‰¹æ€§+æ³¢å½¢ï¼‰< 50ms", ok,
      `æœ¬æœºæµ‹å¾— ${dt.toFixed(1)} msã€‚è‹¥ FAILï¼šå¯é™ä½ samples æˆ–å‡å°‘æ›²çº¿æ•°é‡ï¼ˆæ•™å­¦åœºæ™¯é€šå¸¸ OKï¼‰ã€‚`);
    if (!ok) App.selfTest.failCount++;
  } catch(e){
    addTestItem("æ€§èƒ½æµ‹è¯•", false, "å¼‚å¸¸ï¼š" + String(e));
    App.selfTest.failCount++;
  }
  App.selfTest.done = true;
  renderTests();
}

/* ----------------------------- åˆå§‹åŒ– & äº‹ä»¶ç»‘å®š ----------------------------- */

/* ----------------------------- UI é™„åŠ å±‚ï¼šæ›´å¤šé¢æ¿ ----------------------------- */
function setupMorePanel(){
  const btn = document.getElementById("moreBtn");
  const panel = document.getElementById("morePanel");
  const back = document.getElementById("moreBackdrop");
  const closeBtn = document.getElementById("closeMoreBtn");
  if (!btn || !panel || !back) return;
  const open = ()=>{
    panel.classList.add("open");
    back.classList.add("open");
    btn.classList.add("active");
  };
  const close = ()=>{
    panel.classList.remove("open");
    back.classList.remove("open");
    btn.classList.remove("active");
  };
  btn.addEventListener("click", ()=>{
    if (panel.classList.contains("open")) close();
    else open();
  });
  if (closeBtn) closeBtn.addEventListener("click", close);
  back.addEventListener("click", close);
  // ESC å…³é—­
  window.addEventListener("keydown", (e)=>{
    if (e.key === "Escape" && panel.classList.contains("open")) close();
  });
  // æš´éœ²ç»™è°ƒè¯•/æ‰©å±•
  App.ui = App.ui || {};
  App.ui.openMore = open;
  App.ui.closeMore = close;
}

/* ----------------------------- é¦–æ¬¡è®¿é—®ï¼šå…³æ³¨æç¤ºå¼¹çª— ----------------------------- */
const FOLLOW_STORE_KEY = "bjt_follow_dont_remind_v1";
function setupFollowModal(){
  const back = document.getElementById("followBackdrop");
  const modal = document.getElementById("followModal");
  const cb = document.getElementById("dontRemindFollow");
  const ok = document.getElementById("followOkBtn");
  const go = document.getElementById("followGoBtn");
  if (!back || !modal || !ok || !go || !cb) return;

  const show = ()=>{
    back.classList.add("open");
    modal.classList.add("open");
  };
  const hide = ()=>{
    back.classList.remove("open");
    modal.classList.remove("open");
    try{
      if (cb.checked) localStorage.setItem(FOLLOW_STORE_KEY, "1");
    } catch(_e){}
  };

  ok.addEventListener("click", hide);
  go.addEventListener("click", ()=>{
    window.open("https://space.bilibili.com/269896665", "_blank", "noopener");
    hide();
  });
  back.addEventListener("click", hide);

  // æ”¯æŒ URL å‚æ•° ?nofollow=1 è·³è¿‡
  const sp = new URLSearchParams(location.search);
  if (sp.get("nofollow")==="1") return;
  try{
    const dont = localStorage.getItem(FOLLOW_STORE_KEY) === "1";
    if (!dont){
      setTimeout(show, 450);
    }
  } catch(_e){
    // localStorage ä¸å¯ç”¨æ—¶ä»å¯å¼¹ä¸€æ¬¡
    setTimeout(show, 450);
  }
}

/* ----------------------------- å¿«æ·é”®ï¼šå¾®è°ƒåç½®/è¾“å…¥å¹…åº¦ ----------------------------- */
function isTypingTarget(el){
  if (!el) return false;
  const tag = (el.tagName || "").toUpperCase();
  if (tag==="INPUT" || tag==="TEXTAREA" || tag==="SELECT") return true;
  if (el.isContentEditable) return true;
  return false;
}

function syncParamControl(key){
  const p = currentParams();
  const r = document.getElementById(`paramR_${key}`);
  const n = document.getElementById(`paramN_${key}`);
  App.guard.programmatic = true;
  try{
    if (r) r.value = String(p[key]);
    if (n) n.value = String(p[key]);
  } finally {
    App.guard.programmatic = false;
  }
}

function setupKeyboardNudge(){
  window.addEventListener("keydown", (e)=>{
    if (isTypingTarget(document.activeElement)) return;
    const keys = ["ArrowLeft","ArrowRight","ArrowUp","ArrowDown"];
    if (!keys.includes(e.key)) return;
    e.preventDefault();

    const p = currentParams();
    const hasVBQ = Object.prototype.hasOwnProperty.call(p, "VBQ");
    const stepVB = e.shiftKey ? 0.02 : (e.altKey ? 0.001 : 0.005);
    const stepUi = e.shiftKey ? 0.01 : (e.altKey ? 0.0005 : 0.001);

    if ((e.key==="ArrowLeft" || e.key==="ArrowRight") && hasVBQ){
      const d = (e.key==="ArrowLeft") ? -stepVB : stepVB;
      // VBQ çš„ UI èŒƒå›´æ¥è‡ª PARAM_DEFSï¼ˆè¿™é‡Œå›ºå®šï¼Œé¿å…ä¾èµ– DOMï¼‰
      p.VBQ = clamp(p.VBQ + d, 0.2, 3.2);
      syncParamControl("VBQ");
      onAnyParamChange("VBQ");
      return;
    }

    if (e.key==="ArrowUp" || e.key==="ArrowDown"){
      const d = (e.key==="ArrowDown") ? -stepUi : stepUi;
      const uiRange = document.getElementById("paramR_Ui");
      const max = uiRange ? Number(uiRange.max) : 999;
      p.Ui = clamp(p.Ui + d, 0, isFinite(max)?max:999);
      syncParamControl("Ui");
      onAnyParamChange("Ui");
      return;
    }
  });
}

/* ----------------------------- Q ç‚¹äº¤äº’ï¼šç‚¹å‡»â€œè¾“å‡ºç‰¹æ€§â€å›¾å°è¯•è°ƒ VBQ ----------------------------- */
function tuneVBQToTargetVCE(targetVCE){
  const circuit = App.state.circuit;
  const p0 = currentParams();
  if (!Object.prototype.hasOwnProperty.call(p0, "VBQ")) return false;
  const lo0 = 0.2, hi0 = 3.2;
  const evalVce = (vb)=>{
    const p = {...p0, VBQ: vb};
    const dc = solveDC(p, circuit);
    if (!dc || !dc.ok || !isFiniteNum(dc.VCEQ)) return NaN;
    return dc.VCEQ;
  };
  let lo = lo0, hi = hi0;
  let vLo = evalVce(lo), vHi = evalVce(hi);
  if (!isFiniteNum(vLo) || !isFiniteNum(vHi) || !isFiniteNum(targetVCE)) return false;
  // é€šå¸¸ VBQâ†‘ => ICâ†‘ => VCEQâ†“ï¼ˆå•è°ƒï¼‰ï¼Œä½†ä¸ºç¨³å¥åšâ€œæœ€æ¥è¿‘â€ç­–ç•¥
  let bestVB = p0.VBQ;
  let bestErr = Infinity;
  const updBest = (vb,v)=>{
    const err = Math.abs(v-targetVCE);
    if (err < bestErr){ bestErr=err; bestVB=vb; }
  };
  updBest(lo, vLo);
  updBest(hi, vHi);
  // è‹¥è·¨è¶Šç›®æ ‡ï¼ŒåšäºŒåˆ†ï¼›å¦åˆ™ä¹Ÿåšå›ºå®šæ¬¡æ•°ç¼©å°åŒºé—´
  for (let i=0;i<32;i++){
    const mid = 0.5*(lo+hi);
    const vMid = evalVce(mid);
    if (!isFiniteNum(vMid)) break;
    updBest(mid, vMid);
    const fLo = vLo - targetVCE;
    const fMid = vMid - targetVCE;
    // æœ‰ç¬¦å·å˜åŒ–ï¼šæ ‡å‡†äºŒåˆ†
    if (fLo===0){ bestVB=lo; break; }
    if (fMid===0){ bestVB=mid; break; }
    if (fLo*fMid < 0){
      hi = mid; vHi = vMid;
    } else {
      lo = mid; vLo = vMid;
    }
  }
  // åº”ç”¨
  const p = currentParams();
  p.VBQ = clamp(bestVB, lo0, hi0);
  syncParamControl("VBQ");
  onAnyParamChange("VBQ");
  return true;
}

function setupPlotInteractions(){
  const plotOut = document.getElementById("plotOut");
  if (!plotOut || plotOut._bjtBound) return;
  // Plotly æœªåˆå§‹åŒ–æ—¶ï¼ŒplotOut.on å¯èƒ½ä¸å­˜åœ¨ï¼šç¨åé‡è¯•
  if (typeof plotOut.on !== "function"){
    setTimeout(setupPlotInteractions, 300);
    return;
  }
  plotOut._bjtBound = true;
  plotOut.on('plotly_click', (ev)=>{
    if (!App.state.fsm.powerSwitch) return;
    const pt = ev?.points && ev.points[0];
    if (!pt) return;
    const targetVCE = Number(pt.x);
    const ok = tuneVBQToTargetVCE(targetVCE);
    if (ok){
      setBanner("warn", `å·²å°è¯•æŒ‰ç‚¹å‡»ä½ç½®è°ƒèŠ‚ VBQï¼Œä½¿ VCEQ æ¥è¿‘ ${fmtV(targetVCE)}ï¼ˆæ•™å­¦è¿‘ä¼¼ï¼›è‹¥ä¸ç†æƒ³å¯ç”¨ â†/â†’ å¾®è°ƒï¼‰ã€‚`);
    }
  });
}

function init(){
  fillPresetSelect();
  setupMorePanel();
  setupFollowModal();
  setupKeyboardNudge();
  document.getElementById("circuitSelect").addEventListener("change", ()=>{
    const newC = document.getElementById("circuitSelect").value;
    App.state.circuit = newC;
    buildParamPanel();
    App.state.pending = false;
    document.getElementById("pendingHint").style.display = "none";
    if (App.state.fsm.mode==="HOLD"){
      App.state.pending = true;
      document.getElementById("pendingHint").style.display = "block";
      updateLiveDiag();
      return;
    }
    if (App.state.fsm.mode==="RUN") computeAndRenderSafe();
    else renderPowerOff();
  });
  document.getElementById("modelSelect").addEventListener("change", ()=>{
    App.state.modelMode = document.getElementById("modelSelect").value;
    onAnyParamChange("modelMode");
  });
  document.getElementById("constraintSelect").addEventListener("change", ()=>{
    App.state.constraintMode = document.getElementById("constraintSelect").value;
    onAnyParamChange("constraintMode");
  });
  document.getElementById("applyPresetBtn").addEventListener("click", ()=>{
    const id = document.getElementById("presetSelect").value;
    applyPresetById(id);
  });
  document.getElementById("autoCenterBtn").addEventListener("click", autoBiasCenter);
  document.getElementById("autoJustBtn").addEventListener("click", autoJustNoDist);
  document.getElementById("resetBtn").addEventListener("click", resetAll);
  document.getElementById("revertBtn").addEventListener("click", revertLastGood);
  document.getElementById("exportBtn").addEventListener("click", exportJSON);
  document.getElementById("importBtn").addEventListener("click", ()=>{
    document.getElementById("importFile").click();
  });
  document.getElementById("importFile").addEventListener("change", async (e)=>{
    const file = e.target.files && e.target.files[0];
    if (!file) return;
    await importJSONFile(file);
    e.target.value = "";
  });
  document.getElementById("pngWaveBtn").addEventListener("click", exportPNGWave);
  document.getElementById("pngCharBtn").addEventListener("click", exportPNGChar);
  document.getElementById("powerBtn").addEventListener("click", ()=>{
    setFSM({type:"SET_POWER", value: !App.state.fsm.powerSwitch});
  });
  document.getElementById("holdBtn").addEventListener("click", ()=>{
    setFSM({type:"SET_HOLD", value: !App.state.fsm.holdSwitch});
  });
  buildParamPanel();
  updatePowerHoldButtons();
  renderPowerOff();
  // ç»‘å®šå›¾è¡¨äº¤äº’ï¼ˆç‚¹å‡»è¾“å‡ºç‰¹æ€§è°ƒ VBQï¼‰ï¼Œå¹¶åœ¨ Plotly åˆå§‹åŒ–åå†è¯•ä¸€æ¬¡ä»¥ç¡®ä¿å¯ç”¨
  setupPlotInteractions();
  setTimeout(setupPlotInteractions, 400);

  // Plotly å®¹å™¨å°ºå¯¸éšçª—å£å˜åŒ–æ—¶ï¼Œåšä¸€æ¬¡è½»é‡ resizeï¼ˆé¿å…æŸäº›æµè§ˆå™¨å‡ºç°â€œå›¾è¡¨æŒ¤å‹/ä¸åˆ·æ–°å°ºå¯¸â€ï¼‰
  let resizeTimer = null;
  window.addEventListener("resize", ()=>{
    if (resizeTimer) clearTimeout(resizeTimer);
    resizeTimer = setTimeout(()=>{
      const ids = ["plotUi","plotUo","plotIn","plotTransfer","plotOut"];
      for (const id of ids){
        const el = document.getElementById(id);
        if (el && typeof Plotly !== "undefined"){
          try{ Plotly.Plots.resize(el); } catch(_e){}
        }
      }
    }, 160);
  });
  runSelfTests();
  startRunLoop();
}
window.addEventListener("load", init);
</script>
</body>
</html>